[
  {
    "module_name": "gate_and_2_input",
    "description": "A simple 2-input AND gate.",
    "verilog_code": "module gate_and_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = a & b\n);\n  assign y = a & b;\nendmodule"
  },
  {
    "module_name": "gate_or_2_input",
    "description": "A simple 2-input OR gate.",
    "verilog_code": "module gate_or_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = a | b\n);\n  assign y = a | b;\nendmodule"
  },
  {
    "module_name": "gate_xor_2_input",
    "description": "A simple 2-input XOR gate.",
    "verilog_code": "module gate_xor_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = a ^ b\n);\n  assign y = a ^ b;\nendmodule"
  },
  {
    "module_name": "gate_nand_2_input",
    "description": "A simple 2-input NAND gate.",
    "verilog_code": "module gate_nand_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = ~(a & b)\n);\n  assign y = ~(a & b);\nendmodule"
  },
  {
    "module_name": "gate_nor_2_input",
    "description": "A simple 2-input NOR gate.",
    "verilog_code": "module gate_nor_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = ~(a | b)\n);\n  assign y = ~(a | b);\nendmodule"
  },
  {
    "module_name": "gate_xnor_2_input",
    "description": "A simple 2-input XNOR gate.",
    "verilog_code": "module gate_xnor_2_input (\n  input  a, \\/\\/ Input A\n  input  b, \\/\\/ Input B\n  output y  \\/\\/ Output y = ~(a ^ b)\n);\n  assign y = ~(a ^ b);\nendmodule"
  },
  {
    "module_name": "gate_not",
    "description": "A simple NOT gate (inverter).",
    "verilog_code": "module gate_not (\n  input  a, \\/\\/ Input A\n  output y  \\/\\/ Output y = ~a\n);\n  assign y = ~a;\nendmodule"
  },
  {
    "module_name": "gate_buf",
    "description": "A simple buffer.",
    "verilog_code": "module gate_buf (\n  input  a, \\/\\/ Input A\n  output y  \\/\\/ Output y = a\n);\n  assign y = a;\nendmodule"
  },
  {
    "module_name": "gate_and_n_input",
    "description": "A parameterized N-input AND gate.",
    "verilog_code": "module gate_and_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = &i; \\/\\/ Bitwise reduction AND\n  end\nendmodule"
  },
  {
    "module_name": "gate_or_n_input",
    "description": "A parameterized N-input OR gate.",
    "verilog_code": "module gate_or_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = |i; \\/\\/ Bitwise reduction OR\n  end\nendmodule"
  },
  {
    "module_name": "gate_xor_n_input",
    "description": "A parameterized N-input XOR gate (parity generator).",
    "verilog_code": "module gate_xor_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = ^i; \\/\\/ Bitwise reduction XOR\n  end\nendmodule"
  },
  {
    "module_name": "gate_nand_n_input",
    "description": "A parameterized N-input NAND gate.",
    "verilog_code": "module gate_nand_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = ~(&i); \\/\\/ Bitwise reduction NAND\n  end\nendmodule"
  },
  {
    "module_name": "gate_nor_n_input",
    "description": "A parameterized N-input NOR gate.",
    "verilog_code": "module gate_nor_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = ~(|i); \\/\\/ Bitwise reduction NOR\n  end\nendmodule"
  },
  {
    "module_name": "gate_xnor_n_input",
    "description": "A parameterized N-input XNOR gate (parity checker).",
    "verilog_code": "module gate_xnor_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output reg              o  \\/\\/ 1-bit output\n);\n  always @(*) begin\n    o = ~^i; \\/\\/ Bitwise reduction XNOR\n  end\nendmodule"
  },
  {
    "module_name": "adder_combinational",
    "description": "A parameterized N-bit combinational adder with carry in and carry out.",
    "verilog_code": "module adder_combinational #(\n  parameter WIDTH = 8\n) (\n  input  [WIDTH-1:0] a,     \\/\\/ Input A\n  input  [WIDTH-1:0] b,     \\/\\/ Input B\n  input              cin,   \\/\\/ Carry In\n  output [WIDTH-1:0] sum,   \\/\\/ Sum output\n  output             cout   \\/\\/ Carry Out\n);\n  assign {cout, sum} = a + b + cin;\nendmodule"
  },
  {
    "module_name": "subtractor_combinational",
    "description": "A parameterized N-bit combinational subtractor (a - b) with borrow out.",
    "verilog_code": "module subtractor_combinational #(\n  parameter WIDTH = 8\n) (\n  input  [WIDTH-1:0] a,        \\/\\/ Input A (minuend)\n  input  [WIDTH-1:0] b,        \\/\\/ Input B (subtrahend)\n  output [WIDTH-1:0] diff,     \\/\\/ Difference output\n  output             borrow_out \\/\\/ Borrow Out\n);\n  assign {borrow_out, diff} = a - b;\nendmodule"
  },
  {
    "module_name": "adder_subtractor_combinational",
    "description": "A parameterized N-bit combinational adder/subtractor.",
    "verilog_code": "module adder_subtractor_combinational #(\n  parameter WIDTH = 8\n) (\n  input  [WIDTH-1:0] a,    \\/\\/ Input A\n  input  [WIDTH-1:0] b,    \\/\\/ Input B\n  input              sub,  \\/\\/ Control: 0 for add, 1 for subtract\n  output [WIDTH-1:0] out,  \\/\\/ Result\n  output             cout  \\/\\/ Carry/Borrow out\n);\n  wire [WIDTH-1:0] b_inv;\n  wire [WIDTH:0]   result;\n\n  assign b_inv = b ^ {WIDTH{sub}}; \\/\\/ Invert b if subtracting\n  assign result = a + b_inv + sub;  \\/\\/ Add/Subtract operation\n\n  assign out = result[WIDTH-1:0];\n  assign cout = result[WIDTH];\nendmodule"
  },
  {
    "module_name": "d_flip_flop_async_reset_low",
    "description": "A positive-edge triggered D-type Flip-Flop with active-low asynchronous reset.",
    "verilog_code": "module d_flip_flop_async_reset_low (\n  input clk,     \\/\\/ Clock\n  input rst_n,   \\/\\/ Active-low asynchronous reset\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_async_reset_high",
    "description": "A positive-edge triggered D-type Flip-Flop with active-high asynchronous reset.",
    "verilog_code": "module d_flip_flop_async_reset_high (\n  input clk,     \\/\\/ Clock\n  input rst,     \\/\\/ Active-high asynchronous reset\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_sync_reset_low",
    "description": "A positive-edge triggered D-type Flip-Flop with active-low synchronous reset.",
    "verilog_code": "module d_flip_flop_sync_reset_low (\n  input clk,     \\/\\/ Clock\n  input rst_n,   \\/\\/ Active-low synchronous reset\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (!rst_n)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_sync_reset_high",
    "description": "A positive-edge triggered D-type Flip-Flop with active-high synchronous reset.",
    "verilog_code": "module d_flip_flop_sync_reset_high (\n  input clk,     \\/\\/ Clock\n  input rst,     \\/\\/ Active-high synchronous reset\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 1'b0;\n    else\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_enable",
    "description": "A D-type Flip-Flop with clock enable.",
    "verilog_code": "module d_flip_flop_enable (\n  input clk,     \\/\\/ Clock\n  input ce,      \\/\\/ Clock enable\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (ce)\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_async_reset_enable",
    "description": "A D-FF with active-low asynchronous reset and clock enable.",
    "verilog_code": "module d_flip_flop_async_reset_enable (\n  input clk,     \\/\\/ Clock\n  input rst_n,   \\/\\/ Active-low asynchronous reset\n  input ce,      \\/\\/ Clock enable\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      q <= 1'b0;\n    else if (ce)\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "d_flip_flop_sync_reset_enable",
    "description": "A D-FF with active-high synchronous reset and clock enable.",
    "verilog_code": "module d_flip_flop_sync_reset_enable (\n  input clk,     \\/\\/ Clock\n  input rst,     \\/\\/ Active-high synchronous reset\n  input ce,      \\/\\/ Clock enable\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 1'b0;\n    else if (ce)\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "toggle_flip_flop_async_reset",
    "description": "A Toggle (T-type) Flip-Flop with active-low asynchronous reset.",
    "verilog_code": "module toggle_flip_flop_async_reset (\n  input clk,     \\/\\/ Clock\n  input rst_n,   \\/\\/ Active-low asynchronous reset\n  input t,       \\/\\/ Toggle input\n  output reg q   \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      q <= 1'b0;\n    else if (t)\n      q <= ~q;\n  end\nendmodule"
  },
  {
    "module_name": "jk_flip_flop_async_reset",
    "description": "A JK-type Flip-Flop with active-low asynchronous reset.",
    "verilog_code": "module jk_flip_flop_async_reset (\n  input clk,      \\/\\/ Clock\n  input rst_n,    \\/\\/ Active-low asynchronous reset\n  input j,        \\/\\/ J input\n  input k,        \\/\\/ K input\n  output reg q    \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      q <= 1'b0;\n    end else begin\n      case ({j, k})\n        2'b00: q <= q;     \\/\\/ No change\n        2'b01: q <= 1'b0;  \\/\\/ Reset\n        2'b10: q <= 1'b1;  \\/\\/ Set\n        2'b11: q <= ~q;    \\/\\/ Toggle\n      endcase\n    end\n  end\nendmodule"
  },
  {
    "module_name": "d_latch",
    "description": "A level-sensitive D-type Latch with active-high enable.",
    "verilog_code": "module d_latch (\n  input en,      \\/\\/ Enable (latch is transparent when high)\n  input d,       \\/\\/ Data input\n  output reg q   \\/\\/ Data output\n);\n  always @(en or d) begin\n    if (en)\n      q = d;\n  end\nendmodule"
  },
  {
    "module_name": "sr_latch",
    "description": "A basic SR Latch using NOR gates (active-high S/R). Note: S=1, R=1 is an invalid state.",
    "verilog_code": "module sr_latch (\n  input s,      \\/\\/ Set input\n  input r,      \\/\\/ Reset input\n  output q,     \\/\\/ Q output\n  output q_n   \\/\\/ Q_n output\n);\n  assign q   = ~(r | q_n);\n  assign q_n = ~(s | q);\nendmodule"
  },
  {
    "module_name": "register_sync_reset",
    "description": "A parameterized N-bit register with synchronous active-high reset.",
    "verilog_code": "module register_sync_reset #(\n  parameter WIDTH = 8,\n  parameter RESET_VALUE = 0\n) (\n  input clk,                \\/\\/ Clock\n  input rst,                \\/\\/ Active-high synchronous reset\n  input [WIDTH-1:0] d,      \\/\\/ Data input\n  output reg [WIDTH-1:0] q  \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= RESET_VALUE;\n    else\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "register_async_reset_enable",
    "description": "A parameterized N-bit register with asynchronous reset and clock enable.",
    "verilog_code": "module register_async_reset_enable #(\n  parameter WIDTH = 8,\n  parameter RESET_VALUE = 0\n) (\n  input clk,                \\/\\/ Clock\n  input rst_n,              \\/\\/ Active-low asynchronous reset\n  input ce,                 \\/\\/ Clock Enable\n  input [WIDTH-1:0] d,      \\/\\/ Data input\n  output reg [WIDTH-1:0] q  \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      q <= RESET_VALUE;\n    else if (ce)\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "mux_2_to_1",
    "description": "A 2-to-1 multiplexer.",
    "verilog_code": "module mux_2_to_1 #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] d0,  \\/\\/ Data input 0\n  input [WIDTH-1:0] d1,  \\/\\/ Data input 1\n  input             sel, \\/\\/ Select input\n  output [WIDTH-1:0] y   \\/\\/ Output\n);\n  assign y = sel ? d1 : d0;\nendmodule"
  },
  {
    "module_name": "mux_4_to_1",
    "description": "A 4-to-1 multiplexer.",
    "verilog_code": "module mux_4_to_1 #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] d0,  \\/\\/ Data input 0\n  input [WIDTH-1:0] d1,  \\/\\/ Data input 1\n  input [WIDTH-1:0] d2,  \\/\\/ Data input 2\n  input [WIDTH-1:0] d3,  \\/\\/ Data input 3\n  input [1:0]       sel, \\/\\/ Select input\n  output reg [WIDTH-1:0] y   \\/\\/ Output\n);\n  always @(*) begin\n    case (sel)\n      2'b00: y = d0;\n      2'b01: y = d1;\n      2'b10: y = d2;\n      2'b11: y = d3;\n      default: y = {WIDTH{1'bx}};\n    endcase\n  end\nendmodule"
  },
  {
    "module_name": "mux_generic",
    "description": "A generic N-to-1 multiplexer using a binary select.",
    "verilog_code": "module mux_generic #(\n  parameter NUM_INPUTS = 8,\n  parameter WIDTH = 8,\n  localparam SEL_WIDTH = $clog2(NUM_INPUTS)\n) (\n  input [NUM_INPUTS*WIDTH-1:0] d, \\/\\/ Packed data inputs\n  input [SEL_WIDTH-1:0]        sel, \\/\\/ Select input\n  output [WIDTH-1:0]           y   \\/\\/ Output\n);\n  assign y = d[(sel * WIDTH) +: WIDTH];\nendmodule"
  },
  {
    "module_name": "mux_one_hot",
    "description": "An N-to-1 one-hot select multiplexer.",
    "verilog_code": "module mux_one_hot #(\n  parameter NUM_INPUTS = 4,\n  parameter WIDTH = 8\n) (\n  input [NUM_INPUTS*WIDTH-1:0] d,   \\/\\/ Packed data inputs\n  input [NUM_INPUTS-1:0]       sel, \\/\\/ One-hot select input\n  output reg [WIDTH-1:0]       y    \\/\\/ Output\n);\n  integer i;\n  always @(*) begin\n    y = {WIDTH{1'b0}};\n    for (i = 0; i < NUM_INPUTS; i = i + 1) begin\n      if (sel[i]) begin\n        y = d[i*WIDTH +: WIDTH];\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "demux_1_to_4",
    "description": "A 1-to-4 demultiplexer.",
    "verilog_code": "module demux_1_to_4 #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] d,      \\/\\/ Data input\n  input [1:0]       sel,    \\/\\/ Select input\n  output reg [WIDTH-1:0] y0, \\/\\/ Output 0\n  output reg [WIDTH-1:0] y1, \\/\\/ Output 1\n  output reg [WIDTH-1:0] y2, \\/\\/ Output 2\n  output reg [WIDTH-1:0] y3  \\/\\/ Output 3\n);\n  always @(*) begin\n    y0 = {WIDTH{1'b0}};\n    y1 = {WIDTH{1'b0}};\n    y2 = {WIDTH{1'b0}};\n    y3 = {WIDTH{1'b0}};\n    case (sel)\n      2'b00: y0 = d;\n      2'b01: y1 = d;\n      2'b10: y2 = d;\n      2'b11: y3 = d;\n    endcase\n  end\nendmodule"
  },
  {
    "module_name": "demux_generic",
    "description": "A generic 1-to-N demultiplexer.",
    "verilog_code": "module demux_generic #(\n  parameter NUM_OUTPUTS = 8,\n  parameter WIDTH = 8,\n  localparam SEL_WIDTH = $clog2(NUM_OUTPUTS)\n) (\n  input [WIDTH-1:0]           d,   \\/\\/ Data input\n  input [SEL_WIDTH-1:0]       sel, \\/\\/ Select input\n  output reg [NUM_OUTPUTS*WIDTH-1:0] y    \\/\\/ Packed data outputs\n);\n  integer i;\n  always @(*) begin\n    y = {NUM_OUTPUTS*WIDTH{1'b0}};\n    y[sel*WIDTH +: WIDTH] = d;\n  end\nendmodule"
  },
  {
    "module_name": "encoder_4_to_2",
    "description": "A 4-to-2 binary encoder.",
    "verilog_code": "module encoder_4_to_2 (\n  input [3:0] d, \\/\\/ 4-bit data input\n  output reg [1:0] y \\/\\/ 2-bit encoded output\n);\n  always @(*) begin\n    case (d)\n      4'b0001: y = 2'b00;\n      4'b0010: y = 2'b01;\n      4'b0100: y = 2'b10;\n      4'b1000: y = 2'b11;\n      default: y = 2'bxx;\n    endcase\n  end\nendmodule"
  },
  {
    "module_name": "priority_encoder",
    "description": "A parameterized N-bit priority encoder.",
    "verilog_code": "module priority_encoder #(\n  parameter WIDTH = 8,\n  localparam ADDR_WIDTH = $clog2(WIDTH)\n) (\n  input [WIDTH-1:0]      i,      \\/\\/ N-bit input vector\n  output reg [ADDR_WIDTH-1:0] o_addr, \\/\\/ Encoded address of highest priority bit\n  output reg             o_valid \\/\\/ High if any input bit is high\n);\n  integer k;\n  always @(*) begin\n    o_valid = 1'b0;\n    o_addr = {ADDR_WIDTH{1'b0}};\n    for (k = WIDTH-1; k >= 0; k = k-1) begin\n      if (i[k]) begin\n        o_valid = 1'b1;\n        o_addr = k;\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "decoder_3_to_8",
    "description": "A 3-to-8 line decoder with an enable input.",
    "verilog_code": "module decoder_3_to_8 (\n  input [2:0] a, \\/\\/ 3-bit address input\n  input       en, \\/\\/ Enable input\n  output [7:0] y  \\/\\/ 8-bit decoded output (one-hot)\n);\n  assign y = en ? (1 << a) : 8'h00;\nendmodule"
  },
  {
    "module_name": "comparator_eq",
    "description": "An N-bit equality comparator.",
    "verilog_code": "module comparator_eq #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] a, \\/\\/ Input A\n  input [WIDTH-1:0] b, \\/\\/ Input B\n  output            eq \\/\\/ Output (a == b)\n);\n  assign eq = (a == b);\nendmodule"
  },
  {
    "module_name": "comparator_mag_unsigned",
    "description": "An N-bit unsigned magnitude comparator.",
    "verilog_code": "module comparator_mag_unsigned #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] a, \\/\\/ Input A\n  input [WIDTH-1:0] b, \\/\\/ Input B\n  output            gt, \\/\\/ Output (a > b)\n  output            lt, \\/\\/ Output (a < b)\n  output            eq  \\/\\/ Output (a == b)\n);\n  assign gt = (a > b);\n  assign lt = (a < b);\n  assign eq = (a == b);\nendmodule"
  },
  {
    "module_name": "comparator_mag_signed",
    "description": "An N-bit signed magnitude comparator.",
    "verilog_code": "module comparator_mag_signed #(\n  parameter WIDTH = 8\n) (\n  input signed [WIDTH-1:0] a, \\/\\/ Signed Input A\n  input signed [WIDTH-1:0] b, \\/\\/ Signed Input B\n  output                   gt, \\/\\/ Output (a > b)\n  output                   lt, \\/\\/ Output (a < b)\n  output                   eq  \\/\\/ Output (a == b)\n);\n  assign gt = (a > b);\n  assign lt = (a < b);\n  assign eq = (a == b);\nendmodule"
  },
  {
    "module_name": "binary_to_gray",
    "description": "A parameterized N-bit Binary to Gray code converter.",
    "verilog_code": "module binary_to_gray #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0]  bin, \\/\\/ Binary input\n  output [WIDTH-1:0] gray \\/\\/ Gray code output\n);\n  assign gray = bin ^ (bin >> 1);\nendmodule"
  },
  {
    "module_name": "gray_to_binary",
    "description": "A parameterized N-bit Gray to Binary code converter.",
    "verilog_code": "module gray_to_binary #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0]  gray, \\/\\/ Gray code input\n  output [WIDTH-1:0] bin   \\/\\/ Binary output\n);\n  genvar i;\n  generate\n    assign bin[WIDTH-1] = gray[WIDTH-1];\n    for (i = WIDTH-2; i >= 0; i=i-1) begin: gray2bin_loop\n      assign bin[i] = bin[i+1] ^ gray[i];\n    end\n  endgenerate\nendmodule"
  },
  {
    "module_name": "counter_binary_up_async_reset",
    "description": "A parameterized binary up-counter with asynchronous reset.",
    "verilog_code": "module counter_binary_up_async_reset #(\n  parameter WIDTH = 8,\n  parameter MAX_VAL = 2**WIDTH - 1\n) (\n  input clk,     \\/\\/ Clock\n  input rst_n,   \\/\\/ Active-low asynchronous reset\n  input en,      \\/\\/ Count enable\n  output reg [WIDTH-1:0] count, \\/\\/ Counter output\n  output reg             co     \\/\\/ Carry out / Terminal count\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      count <= 0;\n    else if (en) begin\n      if (count == MAX_VAL)\n        count <= 0;\n      else\n        count <= count + 1;\n    end\n  end\n\n  always @(*) begin\n    co = (count == MAX_VAL) && en;\n  end\nendmodule"
  },
  {
    "module_name": "counter_binary_up_down_sync_reset",
    "description": "A parameterized binary up/down-counter with synchronous reset and load.",
    "verilog_code": "module counter_binary_up_down_sync_reset #(\n  parameter WIDTH = 8\n) (\n  input clk,                  \\/\\/ Clock\n  input rst,                  \\/\\/ Active-high synchronous reset\n  input en,                   \\/\\/ Count enable\n  input up_down,              \\/\\/ Direction: 1 for UP, 0 for DOWN\n  input load,                 \\/\\/ Parallel load enable\n  input [WIDTH-1:0] data_in,  \\/\\/ Parallel data input\n  output reg [WIDTH-1:0] count \\/\\/ Counter output\n);\n  always @(posedge clk) begin\n    if (rst)\n      count <= 0;\n    else if (load)\n      count <= data_in;\n    else if (en) begin\n      if (up_down) \\/\\/ Count up\n        count <= count + 1;\n      else         \\/\\/ Count down\n        count <= count - 1;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "counter_bcd_up",
    "description": "A single-digit BCD (0-9) up-counter.",
    "verilog_code": "module counter_bcd_up (\n  input clk,   \\/\\/ Clock\n  input rst,   \\/\\/ Synchronous Reset\n  input en,    \\/\\/ Enable\n  output reg [3:0] q, \\/\\/ BCD output\n  output co      \\/\\/ Carry out (at 9)\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 4'd0;\n    else if (en) begin\n      if (q == 4'd9)\n        q <= 4'd0;\n      else\n        q <= q + 1;\n    end\n  end\n  assign co = (q == 4'd9) & en;\nendmodule"
  },
  {
    "module_name": "counter_ring",
    "description": "A parameterized N-bit ring counter (one-hot circulating bit).",
    "verilog_code": "module counter_ring #(\n  parameter WIDTH = 8\n) (\n  input clk,   \\/\\/ Clock\n  input rst,   \\/\\/ Synchronous Reset\n  input en,    \\/\\/ Enable\n  output reg [WIDTH-1:0] q \\/\\/ Ring counter output\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= {{(WIDTH-1){1'b0}}, 1'b1}; \\/\\/ Reset to 0...01\n    else if (en)\n      q <= {q[0], q[WIDTH-1:1]}; \\/\\/ Rotate right\n  end\nendmodule"
  },
  {
    "module_name": "counter_johnson",
    "description": "A parameterized N-bit Johnson (twisted-ring) counter.",
    "verilog_code": "module counter_johnson #(\n  parameter WIDTH = 8\n) (\n  input clk,   \\/\\/ Clock\n  input rst,   \\/\\/ Synchronous Reset\n  input en,    \\/\\/ Enable\n  output reg [WIDTH-1:0] q \\/\\/ Johnson counter output\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 0;\n    else if (en)\n      q <= {~q[0], q[WIDTH-1:1]}; \\/\\/ Rotate right with inverted feedback\n  end\nendmodule"
  },
  {
    "module_name": "lfsr_fibonacci",
    "description": "A generic Fibonacci LFSR for pseudo-random number generation. Taps must be provided.",
    "verilog_code": "module lfsr_fibonacci #(\n  parameter WIDTH = 8,\n  parameter TAPS = 8'b10110001 \\/\\/ Example taps for 8-bit maximal length\n) (\n  input clk,                \\/\\/ Clock\n  input rst,                \\/\\/ Synchronous Reset (to non-zero state)\n  input en,                 \\/\\/ Enable\n  output reg [WIDTH-1:0] q  \\/\\/ LFSR state output\n);\n  wire feedback;\n  assign feedback = ^(q & TAPS);\n\n  always @(posedge clk) begin\n    if (rst)\n      q <= {{WIDTH-1{1'b0}}, 1'b1}; \\/\\/ Seed must be non-zero\n    else if (en)\n      q <= {q[WIDTH-2:0], feedback};\n  end\nendmodule"
  },
  {
    "module_name": "lfsr_galois",
    "description": "A generic Galois LFSR for pseudo-random number generation. Taps must be provided.",
    "verilog_code": "module lfsr_galois #(\n  parameter WIDTH = 16,\n  parameter TAPS = 16'hB400 \\/\\/ Taps for CCITT-16\n) (\n  input clk,                \\/\\/ Clock\n  input rst,                \\/\\/ Synchronous Reset\n  input en,                 \\/\\/ Enable\n  output reg [WIDTH-1:0] q  \\/\\/ LFSR state output\n);\n  wire feedback = q[WIDTH-1];\n\n  always @(posedge clk) begin\n    if (rst)\n      q <= {{WIDTH-1{1'b0}}, 1'b1}; \\/\\/ Seed must be non-zero\n    else if (en) begin\n      q <= (q << 1) ^ (TAPS & {WIDTH{feedback}});\n    end\n  end\nendmodule"
  },
  {
    "module_name": "shift_register_siso",
    "description": "A serial-in, serial-out (SISO) shift register.",
    "verilog_code": "module shift_register_siso #(\n  parameter WIDTH = 8\n) (\n  input clk,    \\/\\/ Clock\n  input rst,    \\/\\/ Synchronous Reset\n  input si,     \\/\\/ Serial In\n  output so     \\/\\/ Serial Out\n);\n  reg [WIDTH-1:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (rst)\n      shift_reg <= 0;\n    else\n      shift_reg <= {shift_reg[WIDTH-2:0], si};\n  end\n\n  assign so = shift_reg[WIDTH-1];\nendmodule"
  },
  {
    "module_name": "shift_register_sipo",
    "description": "A serial-in, parallel-out (SIPO) shift register.",
    "verilog_code": "module shift_register_sipo #(\n  parameter WIDTH = 8\n) (\n  input clk,                \\/\\/ Clock\n  input rst,                \\/\\/ Synchronous Reset\n  input si,                 \\/\\/ Serial In\n  output reg [WIDTH-1:0] q  \\/\\/ Parallel Out\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 0;\n    else\n      q <= {q[WIDTH-2:0], si};\n  end\nendmodule"
  },
  {
    "module_name": "shift_register_piso",
    "description": "A parallel-in, serial-out (PISO) shift register.",
    "verilog_code": "module shift_register_piso #(\n  parameter WIDTH = 8\n) (\n  input clk,               \\/\\/ Clock\n  input rst,               \\/\\/ Synchronous Reset\n  input load,              \\/\\/ Parallel load enable\n  input [WIDTH-1:0] d,     \\/\\/ Parallel Data In\n  output so                \\/\\/ Serial Out\n);\n  reg [WIDTH-1:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (rst)\n      shift_reg <= 0;\n    else if (load)\n      shift_reg <= d;\n    else\n      shift_reg <= {shift_reg[WIDTH-2:0], 1'b0}; \\/\\/ Shift in 0s after load\n  end\n\n  assign so = shift_reg[WIDTH-1];\nendmodule"
  },
  {
    "module_name": "shift_register_pipo",
    "description": "A parallel-in, parallel-out (PIPO) shift register. Equivalent to a standard register.",
    "verilog_code": "module shift_register_pipo #(\n  parameter WIDTH = 8\n) (\n  input clk,               \\/\\/ Clock\n  input rst,               \\/\\/ Synchronous Reset\n  input load,              \\/\\/ Load enable\n  input [WIDTH-1:0] d,     \\/\\/ Parallel Data In\n  output reg [WIDTH-1:0] q \\/\\/ Parallel Data Out\n);\n  always @(posedge clk) begin\n    if (rst)\n      q <= 0;\n    else if (load)\n      q <= d;\n  end\nendmodule"
  },
  {
    "module_name": "shift_register_universal",
    "description": "A universal shift register with shift left/right, parallel load, and hold modes.",
    "verilog_code": "module shift_register_universal #(\n  parameter WIDTH = 8\n) (\n  input clk,              \\/\\/ Clock\n  input rst,              \\/\\/ Synchronous Reset\n  input [1:0] mode,       \\/\\/ Mode select: 00=hold, 01=shift_right, 10=shift_left, 11=load\n  input si_r,             \\/\\/ Serial input for right shift\n  input si_l,             \\/\\/ Serial input for left shift\n  input [WIDTH-1:0] d_in, \\/\\/ Parallel data input\n  output reg [WIDTH-1:0] q \\/\\/ Parallel data output\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= 0;\n    end else begin\n      case(mode)\n        2'b00: q <= q; \\/\\/ Hold\n        2'b01: q <= {si_r, q[WIDTH-1:1]}; \\/\\/ Shift Right\n        2'b10: q <= {q[WIDTH-2:0], si_l}; \\/\\/ Shift Left\n        2'b11: q <= d_in; \\/\\/ Parallel Load\n      endcase\n    end\n  end\nendmodule"
  },
  {
    "module_name": "ram_single_port_sync_read",
    "description": "A single-port RAM with synchronous read and write.",
    "verilog_code": "module ram_single_port_sync_read #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input clk,                             \\/\\/ Clock\n  input [ADDR_WIDTH-1:0] addr,           \\/\\/ Address\n  input [DATA_WIDTH-1:0] wdata,          \\/\\/ Write data\n  input we,                              \\/\\/ Write enable\n  output reg [DATA_WIDTH-1:0] rdata       \\/\\/ Read data\n);\n  localparam DEPTH = 1 << ADDR_WIDTH;\n  reg [DATA_WIDTH-1:0] mem [DEPTH-1:0]; \\/\\/ Memory array\n\n  always @(posedge clk) begin\n    if (we) begin\n      mem[addr] <= wdata;\n    end\n    rdata <= mem[addr]; \\/\\/ Read is synchronous\n  end\nendmodule"
  },
  {
    "module_name": "ram_single_port_async_read",
    "description": "A single-port RAM with asynchronous (combinational) read.",
    "verilog_code": "module ram_single_port_async_read #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input clk,                             \\/\\/ Clock\n  input [ADDR_WIDTH-1:0] addr,           \\/\\/ Address\n  input [DATA_WIDTH-1:0] wdata,          \\/\\/ Write data\n  input we,                              \\/\\/ Write enable\n  output [DATA_WIDTH-1:0] rdata          \\/\\/ Read data\n);\n  localparam DEPTH = 1 << ADDR_WIDTH;\n  reg [DATA_WIDTH-1:0] mem [DEPTH-1:0]; \\/\\/ Memory array\n\n  always @(posedge clk) begin\n    if (we) begin\n      mem[addr] <= wdata;\n    end\n  end\n\n  assign rdata = mem[addr]; \\/\\/ Read is asynchronous\nendmodule"
  },
  {
    "module_name": "ram_simple_dual_port",
    "description": "A simple dual-port RAM (1 Read port, 1 Write port).",
    "verilog_code": "module ram_simple_dual_port #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input clk,                              \\/\\/ Clock\n  \\/\\/ Write Port\n  input [ADDR_WIDTH-1:0] wr_addr,\n  input [DATA_WIDTH-1:0] wdata,\n  input we,\n  \\/\\/ Read Port\n  input [ADDR_WIDTH-1:0] rd_addr,\n  output reg [DATA_WIDTH-1:0] rdata\n);\n  localparam DEPTH = 1 << ADDR_WIDTH;\n  reg [DATA_WIDTH-1:0] mem [DEPTH-1:0]; \\/\\/ Memory array\n  reg [ADDR_WIDTH-1:0] rd_addr_reg;\n\n  always @(posedge clk) begin\n    if (we) begin\n      mem[wr_addr] <= wdata;\n    end\n    rd_addr_reg <= rd_addr;\n  end\n\n  assign rdata = mem[rd_addr_reg];\nendmodule"
  },
  {
    "module_name": "ram_true_dual_port",
    "description": "A true dual-port RAM (2 independent Read/Write ports).",
    "verilog_code": "module ram_true_dual_port #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input clk,                              \\/\\/ Clock\n  \\/\\/ Port A\n  input [ADDR_WIDTH-1:0] addr_a,\n  input [DATA_WIDTH-1:0] wdata_a,\n  input we_a,\n  output reg [DATA_WIDTH-1:0] rdata_a,\n  \\/\\/ Port B\n  input [ADDR_WIDTH-1:0] addr_b,\n  input [DATA_WIDTH-1:0] wdata_b,\n  input we_b,\n  output reg [DATA_WIDTH-1:0] rdata_b\n);\n  localparam DEPTH = 1 << ADDR_WIDTH;\n  reg [DATA_WIDTH-1:0] mem [DEPTH-1:0]; \\/\\/ Memory array\n\n  \\/\\/ Port A operation\n  always @(posedge clk) begin\n    if (we_a) begin\n      mem[addr_a] <= wdata_a;\n    end\n    rdata_a <= mem[addr_a];\n  end\n\n  \\/\\/ Port B operation\n  always @(posedge clk) begin\n    if (we_b) begin\n      mem[addr_b] <= wdata_b;\n    end\n    rdata_b <= mem[addr_b];\n  end\nendmodule"
  },
  {
    "module_name": "register_file",
    "description": "A register file with one write port and two read ports.",
    "verilog_code": "module register_file #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 5, \\/\\/ 32 registers\n  parameter NUM_REGS = 1 << ADDR_WIDTH\n) (\n  input clk,                      \\/\\/ Clock\n  \\/\\/ Write Port\n  input [ADDR_WIDTH-1:0] wr_addr,\n  input                  wr_en,\n  input [DATA_WIDTH-1:0] wr_data,\n  \\/\\/ Read Port A\n  input [ADDR_WIDTH-1:0] rd_addr_a,\n  output [DATA_WIDTH-1:0] rd_data_a,\n  \\/\\/ Read Port B\n  input [ADDR_WIDTH-1:0] rd_addr_b,\n  output [DATA_WIDTH-1:0] rd_data_b\n);\n  reg [DATA_WIDTH-1:0] regs [NUM_REGS-1:0];\n\n  \\/\\/ Write Logic (synchronous)\n  always @(posedge clk) begin\n    if (wr_en && wr_addr != 0) begin \\/\\/ Reg 0 is often hardwired to 0\n      regs[wr_addr] <= wr_data;\n    end\n  end\n\n  \\/\\/ Read Logic (asynchronous/combinational)\n  assign rd_data_a = (rd_addr_a == 0) ? 0 : regs[rd_addr_a];\n  assign rd_data_b = (rd_addr_b == 0) ? 0 : regs[rd_addr_b];\nendmodule"
  },
  {
    "module_name": "fifo_sync",
    "description": "A synchronous FIFO with binary pointers.",
    "verilog_code": "module fifo_sync #(\n  parameter DATA_WIDTH = 8,\n  parameter ADDR_WIDTH = 4,\n  localparam DEPTH = 1 << ADDR_WIDTH\n) (\n  input clk,                     \\/\\/ Clock\n  input rst_n,                   \\/\\/ Asynchronous active-low reset\n  \\/\\/ Write interface\n  input [DATA_WIDTH-1:0] wr_data,\n  input wr_en,\n  output full,\n  \\/\\/ Read interface\n  output [DATA_WIDTH-1:0] rd_data,\n  input rd_en,\n  output empty\n);\n  reg [DATA_WIDTH-1:0] mem[DEPTH-1:0];\n  reg [ADDR_WIDTH:0]   wr_ptr;\n  reg [ADDR_WIDTH:0]   rd_ptr;\n  reg [ADDR_WIDTH:0]   count;\n\n  assign rd_data = mem[rd_ptr[ADDR_WIDTH-1:0]];\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      count <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr[ADDR_WIDTH-1:0]] <= wr_data;\n        wr_ptr <= wr_ptr + 1;\n      end\n      if (rd_en && !empty) begin\n        rd_ptr <= rd_ptr + 1;\n      end\n      if ((wr_en && !full) && !(rd_en && !empty)) begin\n        count <= count + 1;\n      end else if (!(wr_en && !full) && (rd_en && !empty)) begin\n        count <= count - 1;\n      end\n    end\n  end\n\n  assign full = (count == DEPTH);\n  assign empty = (count == 0);\nendmodule"
  },
  {
    "module_name": "clock_divider_even",
    "description": "A clock divider that produces a 50% duty cycle clock for any even division factor.",
    "verilog_code": "module clock_divider_even #(\n  parameter DIVISOR = 4 \\/\\/ Must be an even number > 0\n) (\n  input clk_in,\n  input rst,\n  output clk_out\n);\n  localparam COUNT_WIDTH = $clog2(DIVISOR);\n  reg [COUNT_WIDTH-1:0] count;\n  reg clk_reg;\n\n  always @(posedge clk_in or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n      clk_reg <= 0;\n    end else begin\n      if (count == DIVISOR - 1) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n\n      if (count == (DIVISOR/2 - 1)) begin\n        clk_reg <= ~clk_reg;\n      end else if (count == DIVISOR - 1) begin\n        clk_reg <= ~clk_reg;\n      end\n    end\n  end\n\n  assign clk_out = clk_reg;\nendmodule"
  },
  {
    "module_name": "clock_divider_by_2",
    "description": "A simple divide-by-2 clock generator using a T-FlipFlop.",
    "verilog_code": "module clock_divider_by_2 (\n  input clk_in,   \\/\\/ Input clock\n  input rst,      \\/\\/ Synchronous reset\n  output clk_out  \\/\\/ Output clock (half frequency)\n);\n  reg toggle_ff;\n  always @(posedge clk_in) begin\n    if (rst) \n      toggle_ff <= 1'b0;\n    else \n      toggle_ff <= ~toggle_ff;\n  end\n  assign clk_out = toggle_ff;\nendmodule"
  },
  {
    "module_name": "clock_divider_generic",
    "description": "A generic clock divider for any integer division factor (non-50% duty cycle for odd factors).",
    "verilog_code": "module clock_divider_generic #(\n  parameter DIVISOR = 5\n) (\n  input clk_in,   \\/\\/ Input clock\n  input rst,      \\/\\/ Synchronous reset\n  output reg clk_out \\/\\/ Output clock\n);\n  localparam COUNT_WIDTH = $clog2(DIVISOR);\n  reg [COUNT_WIDTH-1:0] counter;\n\n  always @(posedge clk_in) begin\n    if (rst) begin\n      counter <= 0;\n      clk_out <= 0;\n    end else begin\n      if (counter == DIVISOR - 1) begin\n        counter <= 0;\n        clk_out <= ~clk_out;\n      end else begin\n        counter <= counter + 1;\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "clock_gate_latch_free",
    "description": "A simple, latch-free clock gating cell. Prevents glitches on the gated clock.",
    "verilog_code": "module clock_gate_latch_free (\n  input clk,     \\/\\/ Input clock\n  input en,      \\/\\/ Clock enable (must be stable during clk high)\n  output gclk   \\/\\/ Gated clock output\n);\n  reg en_latch;\n  always @(negedge clk) begin\n    en_latch <= en;\n  end\n  assign gclk = clk & en_latch;\nendmodule"
  },
  {
    "module_name": "reset_synchronizer",
    "description": "A standard 2-flop reset synchronizer to safely bring an asynchronous reset into a new clock domain.",
    "verilog_code": "module reset_synchronizer (\n  input clk,        \\/\\/ Destination clock domain\n  input async_rst_n,  \\/\\/ Asynchronous reset from another domain (active-low)\n  output sync_rst_n   \\/\\/ Synchronized reset for the destination domain (active-low)\n);\n  reg rst_meta, rst_sync;\n\n  always @(posedge clk or negedge async_rst_n) begin\n    if (!async_rst_n)\n    begin\n      rst_meta <= 1'b0;\n      rst_sync <= 1'b0;\n    end\n    else\n    begin\n      rst_meta <= 1'b1;\n      rst_sync <= rst_meta;\n    end\n  end\n  assign sync_rst_n = rst_sync;\nendmodule"
  },
  {
    "module_name": "edge_detector_posedge",
    "description": "Detects a rising edge and produces a single-cycle pulse.",
    "verilog_code": "module edge_detector_posedge (\n  input clk,    \\/\\/ Clock\n  input rst_n,  \\/\\/ Active-low async reset\n  input din,    \\/\\/ Data input\n  output pulse  \\/\\/ Single-cycle pulse on posedge of din\n);\n  reg din_d1;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      din_d1 <= 1'b0;\n    else\n      din_d1 <= din;\n  end\n\n  assign pulse = din & ~din_d1;\nendmodule"
  },
  {
    "module_name": "edge_detector_negedge",
    "description": "Detects a falling edge and produces a single-cycle pulse.",
    "verilog_code": "module edge_detector_negedge (\n  input clk,    \\/\\/ Clock\n  input rst_n,  \\/\\/ Active-low async reset\n  input din,    \\/\\/ Data input\n  output pulse  \\/\\/ Single-cycle pulse on negedge of din\n);\n  reg din_d1;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      din_d1 <= 1'b0;\n    else\n      din_d1 <= din;\n  end\n\n  assign pulse = ~din & din_d1;\nendmodule"
  },
  {
    "module_name": "edge_detector_any_edge",
    "description": "Detects any edge (rising or falling) and produces a single-cycle pulse.",
    "verilog_code": "module edge_detector_any_edge (\n  input clk,    \\/\\/ Clock\n  input rst_n,  \\/\\/ Active-low async reset\n  input din,    \\/\\/ Data input\n  output pulse  \\/\\/ Single-cycle pulse on any edge of din\n);\n  reg din_d1;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      din_d1 <= 1'b0;\n    else\n      din_d1 <= din;\n  end\n\n  assign pulse = din ^ din_d1;\nendmodule"
  },
  {
    "module_name": "debouncer",
    "description": "A counter-based switch debouncer.",
    "verilog_code": "module debouncer #(\n  parameter CLK_FREQ = 50_000_000, \\/\\/ 50 MHz clock\n  parameter DEBOUNCE_TIME_MS = 10,  \\/\\/ 10 ms debounce time\n  localparam MAX_COUNT = CLK_FREQ * DEBOUNCE_TIME_MS / 1000,\n  localparam COUNT_WIDTH = $clog2(MAX_COUNT)\n) (\n  input clk,              \\/\\/ System clock\n  input rst_n,            \\/\\/ Async reset\n  input noisy_in,         \\/\\/ Raw input from a button/switch\n  output reg clean_out    \\/\\/ Debounced output\n);\n  reg [1:0] state_reg, next_state;\n  reg [COUNT_WIDTH-1:0] count_reg, next_count;\n  localparam S_IDLE = 2'd0, S_WAIT0 = 2'd1, S_WAIT1 = 2'd2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      state_reg <= S_IDLE;\n      count_reg <= 0;\n      clean_out <= 0;\n    end else begin\n      state_reg <= next_state;\n      count_reg <= next_count;\n      if (state_reg == S_IDLE)\n          clean_out <= noisy_in;\n    end\n  end\n\n  always @(*) begin\n    next_state = state_reg;\n    next_count = count_reg;\n    case (state_reg)\n      S_IDLE: begin\n        if (noisy_in != clean_out) begin\n          next_state = (noisy_in == 1'b1) ? S_WAIT1 : S_WAIT0;\n          next_count = 0;\n        end\n      end\n      S_WAIT0, S_WAIT1: begin\n        if (noisy_in == clean_out) begin \\/\\/ Glitch, return to idle\n          next_state = S_IDLE;\n        end else if (count_reg == MAX_COUNT - 1) begin \\/\\/ Debounce time passed\n          next_state = S_IDLE;\n        end else begin\n          next_count = count_reg + 1;\n        end\n      end\n      default: next_state = S_IDLE;\n    endcase\n  end\nendmodule"
  },
  {
    "module_name": "arbiter_fixed_priority",
    "description": "A fixed-priority arbiter. Input 0 has the highest priority.",
    "verilog_code": "module arbiter_fixed_priority #(\n  parameter NUM_REQUESTERS = 4\n) (\n  input [NUM_REQUESTERS-1:0]  req,    \\/\\/ Request lines\n  output [NUM_REQUESTERS-1:0] gnt     \\/\\/ Grant lines (one-hot)\n);\n  genvar i;\n  generate\n    for (i = 0; i < NUM_REQUESTERS; i=i+1) begin: grant_logic\n      assign gnt[i] = req[i] & ~|(req[i-1:0]);\n    end\n  endgenerate\nendmodule"
  },
  {
    "module_name": "arbiter_round_robin",
    "description": "A round-robin arbiter that grants requests in a circular fashion.",
    "verilog_code": "module arbiter_round_robin #(\n  parameter NUM_REQUESTERS = 4,\n  localparam PTR_WIDTH = $clog2(NUM_REQUESTERS)\n) (\n  input clk,                      \\/\\/ Clock\n  input rst_n,                    \\/\\/ Async reset\n  input [NUM_REQUESTERS-1:0]  req, \\/\\/ Request lines\n  output reg [NUM_REQUESTERS-1:0] gnt \\/\\/ Grant lines (one-hot)\n);\n  reg [PTR_WIDTH-1:0] priority_ptr;\n  wire [NUM_REQUESTERS-1:0] masked_req;\n  wire grant_valid;\n\n  assign masked_req = req & (req - (1 << priority_ptr));\n  assign grant_valid = |req;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      priority_ptr <= 0;\n    end else if (grant_valid) begin \\/\\/ Update priority pointer only when a grant is issued\n      if (|masked_req) begin\n        priority_ptr <= $clog2(|(masked_req & -masked_req));\n      end else begin\n        priority_ptr <= $clog2(|(req & -req));\n      end\n    end\n  end\n\n  always @(*) begin\n    if (|masked_req)\n      gnt = masked_req & -masked_req; \\/\\/ Grant the lowest bit of the masked request\n    else\n      gnt = req & -req; \\/\\/ Grant the lowest bit of the original request\n  end\nendmodule"
  },
  {
    "module_name": "multiplier_combinational",
    "description": "A parameterized N-bit unsigned combinational multiplier.",
    "verilog_code": "module multiplier_combinational #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] a,       \\/\\/ Multiplicand\n  input [WIDTH-1:0] b,       \\/\\/ Multiplier\n  output [2*WIDTH-1:0] prod   \\/\\/ Product\n);\n  assign prod = a * b;\nendmodule"
  },
  {
    "module_name": "multiplier_pipelined",
    "description": "A parameterized N-bit pipelined unsigned multiplier.",
    "verilog_code": "module multiplier_pipelined #(\n  parameter WIDTH = 8,\n  parameter PIPELINE_STAGES = 2\n) (\n  input clk,                \\/\\/ Clock\n  input rst_n,              \\/\\/ Async Reset\n  input [WIDTH-1:0] a,      \\/\\/ Multiplicand\n  input [WIDTH-1:0] b,      \\/\\/ Multiplier\n  output [2*WIDTH-1:0] prod \\/\\/ Product\n);\n  reg [2*WIDTH-1:0] product_reg;\n\n  \\/\\/ This is a simplified model. A real pipelined multiplier would break down the partial products.\n  \\/\\/ For demonstration, we just register the inputs and the output.\n  reg [WIDTH-1:0] a_pipe [PIPELINE_STAGES-1:0];\n  reg [WIDTH-1:0] b_pipe [PIPELINE_STAGES-1:0];\n  reg [2*WIDTH-1:0] prod_pipe;\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for(i=0; i<PIPELINE_STAGES; i=i+1) begin\n        a_pipe[i] <= 0;\n        b_pipe[i] <= 0;\n      end\n      prod_pipe <= 0;\n    end\n    else begin\n      a_pipe[0] <= a;\n      b_pipe[0] <= b;\n      for(i=1; i<PIPELINE_STAGES; i=i+1) begin\n        a_pipe[i] <= a_pipe[i-1];\n        b_pipe[i] <= b_pipe[i-1];\n      end\n      prod_pipe <= a_pipe[PIPELINE_STAGES-1] * b_pipe[PIPELINE_STAGES-1];\n    end\n  end\n\n  assign prod = prod_pipe;\nendmodule"
  },
  {
    "module_name": "barrel_shifter_combinational",
    "description": "A combinational barrel shifter for left/right logical shifts.",
    "verilog_code": "module barrel_shifter_combinational #(\n  parameter DATA_WIDTH = 32,\n  localparam SHIFT_WIDTH = $clog2(DATA_WIDTH)\n) (\n  input [DATA_WIDTH-1:0]  data_in,   \\/\\/ Data to be shifted\n  input [SHIFT_WIDTH-1:0] shift_amt, \\/\\/ Amount to shift by\n  input                   shift_left,  \\/\\/ Direction: 1 for left, 0 for right\n  output [DATA_WIDTH-1:0] data_out   \\/\\/ Shifted data\n);\n  assign data_out = shift_left ? (data_in << shift_amt) : (data_in >> shift_amt);\nendmodule"
  },
  {
    "module_name": "leading_zero_detector",
    "description": "A parameterized combinational leading zero detector.",
    "verilog_code": "module leading_zero_detector #(\n  parameter WIDTH = 32,\n  localparam COUNT_WIDTH = $clog2(WIDTH+1)\n) (\n  input [WIDTH-1:0] data_in,      \\/\\/ Input data\n  output reg [COUNT_WIDTH-1:0] count, \\/\\/ Number of leading zeros\n  output reg zero                 \\/\\/ High if data_in is all zeros\n);\n  integer i;\n  always@(*) begin\n    count = 0;\n    zero = 1'b0;\n    if (|data_in == 1'b0) begin\n        count = WIDTH;\n        zero = 1'b1;\n    end else begin\n        count = 0;\n        for(i = WIDTH-1; i >= 0; i=i-1) begin\n           if(data_in[i] == 1'b0) begin\n               count = count + 1;\n           end else begin\n               i = -1; \\/\\/ exit loop\n           end\n        end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "population_count",
    "description": "Counts the number of set bits (1s) in a vector. Also known as Hamming weight.",
    "verilog_code": "module population_count #(\n  parameter WIDTH = 16,\n  localparam COUNT_WIDTH = $clog2(WIDTH+1)\n) (\n  input [WIDTH-1:0] data_in,      \\/\\/ Input data\n  output reg [COUNT_WIDTH-1:0] count \\/\\/ Number of set bits\n);\n  integer i;\n  always @(*) begin\n    count = 0;\n    for (i = 0; i < WIDTH; i = i + 1) begin\n      count = count + data_in[i];\n    end\n  end\nendmodule"
  },
  {
    "module_name": "saturating_adder_unsigned",
    "description": "An N-bit unsigned adder that saturates at the maximum value on overflow.",
    "verilog_code": "module saturating_adder_unsigned #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] a,   \\/\\/ Input A\n  input [WIDTH-1:0] b,   \\/\\/ Input B\n  output [WIDTH-1:0] sum \\/\\/ Saturated sum\n);\n  wire [WIDTH:0] temp_sum;\n  assign temp_sum = {1'b0, a} + {1'b0, b};\n  assign sum = temp_sum[WIDTH] ? {WIDTH{1'b1}} : temp_sum[WIDTH-1:0];\nendmodule"
  },
  {
    "module_name": "parity_generator_even",
    "description": "Generates an even parity bit for an N-bit data vector.",
    "verilog_code": "module parity_generator_even #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] data_in, \\/\\/ Input data\n  output            parity_bit \\/\\/ Even parity bit\n);\n  assign parity_bit = ^data_in;\nendmodule"
  },
  {
    "module_name": "parity_checker_even",
    "description": "Checks for even parity in an N-bit data vector with its parity bit. Error is high on failure.",
    "verilog_code": "module parity_checker_even #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] data_in, \\/\\/ Input data\n  input             parity_in, \\/\\/ Received parity bit\n  output            error      \\/\\/ Parity error flag\n);\n  assign error = (^data_in) ^ parity_in;\nendmodule"
  },
  {
    "module_name": "cdc_2flop_synchronizer",
    "description": "A standard 2-flop synchronizer for safely passing a single-bit signal across clock domains.",
    "verilog_code": "module cdc_2flop_synchronizer (\n  input clk,       \\/\\/ Destination clock domain\n  input rst_n,     \\/\\/ Destination domain reset (active-low)\n  input data_in,   \\/\\/ Asynchronous data input from source domain\n  output data_out  \\/\\/ Synchronized data output\n);\n  reg meta_flop, sync_flop;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      meta_flop <= 1'b0;\n      sync_flop <= 1'b0;\n    end else begin\n      meta_flop <= data_in;\n      sync_flop <= meta_flop;\n    end\n  end\n\n  assign data_out = sync_flop;\nendmodule"
  },
  {
    "module_name": "cdc_pulse_synchronizer",
    "description": "A synchronizer for single-cycle pulses, ensuring a single-cycle pulse is generated in the destination domain.",
    "verilog_code": "module cdc_pulse_synchronizer (\n  input clk,     \\/\\/ Destination clock domain\n  input rst_n,   \\/\\/ Destination domain reset\n  input pulse_in,  \\/\\/ Asynchronous pulse input (must be >= 1 dest clk cycle)\n  output pulse_out \\/\\/ Synchronized single-cycle pulse output\n);\n  reg s1, s2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      s1 <= 1'b0;\n      s2 <= 1'b0;\n    end else begin\n      s1 <= pulse_in;\n      s2 <= s1;\n    end\n  end\n\n  assign pulse_out = s2 & ~s1;\nendmodule"
  },
  {
    "module_name": "async_fifo",
    "description": "A complete asynchronous (dual-clock) FIFO using Gray code pointers.",
    "verilog_code": "module async_fifo #(\n  parameter DATA_WIDTH = 8,\n  parameter ADDR_WIDTH = 4,\n  localparam DEPTH = 1 << ADDR_WIDTH\n) (\n  \\/\\/ Write Clock Domain\n  input wr_clk,\n  input wr_rst_n,\n  input wr_en,\n  input [DATA_WIDTH-1:0] wr_data,\n  output wr_full,\n  \\/\\/ Read Clock Domain\n  input rd_clk,\n  input rd_rst_n,\n  input rd_en,\n  output [DATA_WIDTH-1:0] rd_data,\n  output rd_empty\n);\n  reg [DATA_WIDTH-1:0] mem[DEPTH-1:0];\n\n  \\/\\/ Write pointers (binary for addressing, gray for crossing)\n  reg  [ADDR_WIDTH:0] wr_ptr_bin;\n  wire [ADDR_WIDTH:0] wr_ptr_gray;\n  reg  [ADDR_WIDTH:0] rd_ptr_gray_sync;\n\n  \\/\\/ Read pointers (binary for addressing, gray for crossing)\n  reg  [ADDR_WIDTH:0] rd_ptr_bin;\n  wire [ADDR_WIDTH:0] rd_ptr_gray;\n  reg  [ADDR_WIDTH:0] wr_ptr_gray_sync;\n\n  \\/\\/ --- Write Domain Logic ---\n  assign wr_ptr_gray = (wr_ptr_bin >> 1) ^ wr_ptr_bin;\n  assign wr_full = (wr_ptr_gray == {~rd_ptr_gray_sync[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync[ADDR_WIDTH-2:0]});\n\n  always @(posedge wr_clk or negedge wr_rst_n) begin\n    if (!wr_rst_n) begin\n      wr_ptr_bin <= 0;\n    end else if (wr_en && !wr_full) begin\n      mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;\n      wr_ptr_bin <= wr_ptr_bin + 1;\n    end\n  end\n\n  \\/\\/ --- Read Domain Logic ---\n  assign rd_ptr_gray = (rd_ptr_bin >> 1) ^ rd_ptr_bin;\n  assign rd_data = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];\n  assign rd_empty = (wr_ptr_gray_sync == rd_ptr_gray);\n\n  always @(posedge rd_clk or negedge rd_rst_n) begin\n    if (!rd_rst_n) begin\n      rd_ptr_bin <= 0;\n    end else if (rd_en && !rd_empty) begin\n      rd_ptr_bin <= rd_ptr_bin + 1;\n    end\n  end\n\n  \\/\\/ --- CDC Logic ---\n  \\/\\/ Read pointer synchronized to write clock\n  always @(posedge wr_clk or negedge wr_rst_n) begin\n    if (!wr_rst_n) begin\n      rd_ptr_gray_sync <= 0;\n    end else begin\n      rd_ptr_gray_sync <= rd_ptr_gray; \\/\\/ Note: This needs a proper 2-flop synchronizer\n    end\n  end\n\n  \\/\\/ Write pointer synchronized to read clock\n  always @(posedge rd_clk or negedge rd_rst_n) begin\n    if (!rd_rst_n) begin\n      wr_ptr_gray_sync <= 0;\n    end else begin\n      wr_ptr_gray_sync <= wr_ptr_gray; \\/\\/ Note: This needs a proper 2-flop synchronizer\n    end\n  end\nendmodule"
  },
  {
    "module_name": "uart_tx",
    "description": "A simple UART transmitter module.",
    "verilog_code": "module uart_tx #(\n  parameter CLK_FREQ = 50_000_000,\n  parameter BAUD_RATE = 9600\n) (\n  input clk,                    \\/\\/ System clock\n  input rst_n,                  \\/\\/ Async reset\n  input tx_start,               \\/\\/ Start transmission pulse\n  input [7:0] tx_data,          \\/\\/ Data to transmit\n  output tx_serial,              \\/\\/ Serial output line\n  output reg tx_busy            \\/\\/ Busy flag\n);\n  localparam DIVISOR = CLK_FREQ / BAUD_RATE;\n  localparam S_IDLE = 3'd0, S_START = 3'd1, S_DATA = 3'd2, S_STOP = 3'd3;\n\n  reg [2:0] state_reg, next_state;\n  reg [$clog2(DIVISOR)-1:0] clk_count;\n  reg [2:0] bit_count;\n  reg [7:0] data_reg;\n  reg tx_reg;\n\n  assign tx_serial = tx_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      state_reg <= S_IDLE;\n      tx_busy <= 1'b0;\n      clk_count <= 0;\n      bit_count <= 0;\n      tx_reg <= 1'b1; \\/\\/ Idle line is high\n      data_reg <= 0;\n    end else begin\n      state_reg <= next_state;\n      if(next_state != state_reg) begin\n          clk_count <= 0;\n      end else if (state_reg != S_IDLE) begin\n          if(clk_count == DIVISOR-1) clk_count <= 0; else clk_count <= clk_count + 1;\n      end\n      if(tx_start && !tx_busy) begin\n          data_reg <= tx_data;\n          tx_busy <= 1'b1;\n      end\n      if(state_reg == S_STOP && clk_count == DIVISOR-1) tx_busy <= 1'b0;\n      if(next_state == S_DATA && state_reg == S_START && clk_count == DIVISOR-1) bit_count <= 0; \n      else if (state_reg == S_DATA && clk_count == DIVISOR-1) bit_count <= bit_count + 1;\n      if(next_state == S_IDLE) tx_reg <= 1'b1; \n      else if(next_state == S_START) tx_reg <= 1'b0; \n      else if(next_state == S_STOP) tx_reg <= 1'b1; \n      else if(state_reg == S_DATA && clk_count == DIVISOR-1) tx_reg <= data_reg[bit_count+1]; \n      else if(next_state == S_DATA && state_reg == S_START) tx_reg <= data_reg[0]; \n    end\n  end\n  \n  always @(*) begin\n    next_state = state_reg;\n    case(state_reg)\n        S_IDLE: if(tx_start && !tx_busy) next_state = S_START;\n        S_START: if(clk_count == DIVISOR-1) next_state = S_DATA;\n        S_DATA: if(clk_count == DIVISOR-1 && bit_count == 7) next_state = S_STOP;\n        S_STOP: if(clk_count == DIVISOR-1) next_state = S_IDLE;\n    endcase\n  end\nendmodule"
  },
  {
    "module_name": "uart_rx",
    "description": "A simple UART receiver module with oversampling.",
    "verilog_code": "module uart_rx #(\n  parameter CLK_FREQ = 50_000_000,\n  parameter BAUD_RATE = 9600,\n  parameter OVERSAMPLE = 16\n) (\n  input clk,                 \\/\\/ System clock\n  input rst_n,               \\/\\/ Async reset\n  input rx_serial,           \\/\\/ Serial input line\n  output reg rx_valid,        \\/\\/ Pulse high when data is ready\n  output reg [7:0] rx_data    \\/\\/ Received data\n);\n  localparam DIVISOR = CLK_FREQ / (BAUD_RATE * OVERSAMPLE);\n  localparam S_IDLE = 2'd0, S_START = 2'd1, S_DATA = 2'd2, S_STOP = 2'd3;\n  \n  reg [1:0] state_reg;\n  reg [$clog2(DIVISOR)-1:0] sample_count;\n  reg [3:0] bit_count;\n  reg [7:0] data_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      state_reg <= S_IDLE;\n      sample_count <= 0;\n      bit_count <= 0;\n      rx_valid <= 1'b0;\n    end else begin\n      rx_valid <= 1'b0; \\/\\/ Pulse behavior\n      case(state_reg)\n        S_IDLE:\n          if (~rx_serial) begin \\/\\/ Start bit detected\n            state_reg <= S_START;\n            sample_count <= 0;\n          end\n        S_START:\n          if (sample_count == DIVISOR * OVERSAMPLE / 2 - 1) begin \\/\\/ Wait for middle of start bit\n            if (~rx_serial) begin \\/\\/ Confirm start bit\n              state_reg <= S_DATA;\n              sample_count <= 0;\n              bit_count <= 0;\n            end else begin\n              state_reg <= S_IDLE; \\/\\/ Glitch, return to idle\n            end\n          end else begin\n            sample_count <= sample_count + 1;\n          end\n        S_DATA:\n          if (sample_count == DIVISOR * OVERSAMPLE - 1) begin\n            sample_count <= 0;\n            data_reg[bit_count] <= rx_serial;\n            if (bit_count == 7) begin\n              state_reg <= S_STOP;\n            end else begin\n              bit_count <= bit_count + 1;\n            end\n          end else begin\n            sample_count <= sample_count + 1;\n          end\n        S_STOP:\n          if (sample_count == DIVISOR * OVERSAMPLE - 1) begin\n            state_reg <= S_IDLE;\n            rx_data <= data_reg;\n            rx_valid <= 1'b1;\n          end else begin\n            sample_count <= sample_count + 1;\n          end\n      endcase\n    end\n  end\nendmodule"
  },
  {
    "module_name": "spi_master",
    "description": "A basic SPI master supporting Mode 0 (CPOL=0, CPHA=0).",
    "verilog_code": "module spi_master #(\n  parameter CLK_DIV = 4\n) (\n  input clk,            \\/\\/ System clock\n  input rst_n,          \\/\\/ Async reset\n  input start,          \\/\\/ Start transaction pulse\n  input [7:0] data_tx,  \\/\\/ Data to transmit\n  output reg [7:0] data_rx, \\/\\/ Data received\n  output reg busy,       \\/\\/ Busy flag\n  output reg spi_sck,   \\/\\/ SPI Clock\n  output spi_mosi,      \\/\\/ Master Out, Slave In\n  input  spi_miso       \\/\\/ Master In, Slave Out\n);\n  reg [$clog2(CLK_DIV)-1:0] clk_count;\n  reg [3:0] bit_count;\n  reg [7:0] tx_reg, rx_reg;\n\n  assign spi_mosi = tx_reg[7];\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      busy <= 1'b0;\n      spi_sck <= 1'b0;\n      clk_count <= 0;\n      bit_count <= 0;\n    end else begin\n      if (start && !busy) begin\n        busy <= 1'b1;\n        tx_reg <= data_tx;\n        clk_count <= 0;\n        bit_count <= 0;\n        spi_sck <= 1'b0;\n      end else if (busy) begin\n        if (clk_count == CLK_DIV-1) begin \\/\\/ Falling edge of spi_sck\n          spi_sck <= 1'b0;\n          clk_count <= 0;\n          if (bit_count == 8) begin \\/\\/ Transaction done\n            busy <= 1'b0;\n            data_rx <= rx_reg;\n          end else begin\n            tx_reg <= tx_reg << 1;\n          end\n        end else if (clk_count == CLK_DIV/2-1) begin \\/\\/ Rising edge of spi_sck\n          spi_sck <= 1'b1;\n          clk_count <= clk_count + 1;\n          rx_reg <= {rx_reg[6:0], spi_miso};\n          bit_count <= bit_count + 1;\n        end else begin\n          clk_count <= clk_count + 1;\n        end\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "spi_slave",
    "description": "A basic SPI slave supporting Mode 0 (CPOL=0, CPHA=0).",
    "verilog_code": "module spi_slave (\n  input clk,           \\/\\/ System clock\n  input rst_n,         \\/\\/ Async reset\n  input spi_sck,       \\/\\/ SPI Clock from master\n  input spi_mosi,      \\/\\/ Master Out, Slave In\n  input spi_cs,        \\/\\/ Chip Select\n  output reg spi_miso,  \\/\\/ Master In, Slave Out\n  output reg [7:0] data_out, \\/\\/ Received data\n  input [7:0] data_in      \\/\\/ Data to be transmitted\n);\n  reg [7:0] tx_reg, rx_reg;\n  reg [3:0] bit_count;\n  reg sck_d1, sck_d2;\n\n  always @(posedge clk) begin\n    sck_d1 <= spi_sck;\n    sck_d2 <= sck_d1;\n  end\n\n  wire sck_posedge = ~sck_d2 & sck_d1;\n  wire sck_negedge = sck_d2 & ~sck_d1;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      tx_reg <= 0;\n      spi_miso <= 1'b0;\n      bit_count <= 0;\n      data_out <= 0;\n    end else begin\n      if (spi_cs) begin \\/\\/ Chip is not selected\n        bit_count <= 0;\n      end else begin \\/\\/ Chip is selected\n        if (bit_count == 0) \\/\\/ Load tx data on first edge\n            tx_reg <= data_in;\n            \n        if(sck_negedge) begin \\/\\/ CPHA=0: MOSI is stable, shift MISO out\n          spi_miso <= tx_reg[7];\n          tx_reg <= tx_reg << 1;\n        end\n        if(sck_posedge) begin \\/\\/ CPHA=0: Sample MOSI\n          rx_reg <= {rx_reg[6:0], spi_mosi};\n          bit_count <= bit_count + 1;\n          if(bit_count == 7) \\/\\/ last bit sampled\n             data_out <= {rx_reg[6:0], spi_mosi};\n        end\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "pwm_generator",
    "description": "A Pulse-Width Modulation (PWM) generator with configurable period and duty cycle.",
    "verilog_code": "module pwm_generator #(\n  parameter COUNTER_WIDTH = 8\n) (\n  input clk,                    \\/\\/ System clock\n  input rst_n,                  \\/\\/ Async reset\n  input [COUNTER_WIDTH-1:0] period, \\/\\/ PWM period (max count)\n  input [COUNTER_WIDTH-1:0] duty,   \\/\\/ Duty cycle (compare value)\n  output reg pwm_out             \\/\\/ PWM output signal\n);\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      counter <= 0;\n      pwm_out <= 0;\n    end else begin\n      if (counter >= period) begin\n        counter <= 0;\n      end else begin\n        counter <= counter + 1;\n      end\n      if (counter < duty) begin\n        pwm_out <= 1'b1;\n      end else begin\n        pwm_out <= 1'b0;\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "i2c_master_controller",
    "description": "A basic I2C master controller FSM (does not include SCL generation).",
    "verilog_code": "module i2c_master_controller(\n    input clk,          \\/\\/ System clock\n    input rst_n,        \\/\\/ Reset\n    input start,        \\/\\/ Start command\n    input stop,         \\/\\/ Stop command\n    input read,         \\/\\/ Read command\n    input write,        \\/\\/ Write command\n    input ack_in,       \\/\\/ ACK from slave\n    output reg scl,     \\/\\/ I2C clock\n    inout sda,          \\/\\/ I2C data\n    output reg busy,    \\/\\/ Busy flag\n    output reg ack_out  \\/\\/ ACK to slave\n);\n    \\/\\/ This is a simplified FSM structure. A full implementation is complex.\n    localparam S_IDLE = 0, S_START_COND = 1, S_WRITE_ADDR = 2, S_WAIT_ACK1 = 3, S_WRITE_DATA = 4, S_WAIT_ACK2 = 5, S_READ_DATA=6, S_SEND_ACK=7, S_STOP_COND = 8;\n    reg [3:0] state;\n\n    assign sda = (state == S_WRITE_ADDR || state == S_WRITE_DATA) ? data_bit_out : 1'bz;\n    wire data_bit_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= S_IDLE;\n            scl <= 1'b1;\n            busy <= 1'b0;\n        end else begin\n            case(state)\n                S_IDLE:\n                    if(start) begin\n                        state <= S_START_COND;\n                        busy <= 1'b1;\n                    end\n                S_START_COND:\n                    \\/\\/ Generate start condition logic (SDA low while SCL high)\n                    state <= S_WRITE_ADDR;\n                \\/\\/ ... and so on for other states\n                S_STOP_COND:\n                    \\/\\/ Generate stop condition logic (SDA high while SCL high)\n                    state <= S_IDLE;\n                    busy <= 1'b0;\n            endcase\n        end\n    end\nendmodule"
  },
  {
    "module_name": "vga_timing_640x480",
    "description": "Generates VGA timing signals for a 640x480 @ 60Hz display.",
    "verilog_code": "module vga_timing_640x480(\n    input clk_25m,  \\/\\/ 25.175 MHz pixel clock\n    input rst_n,    \\/\\/ Reset\n    output reg h_sync, \\/\\/ Horizontal sync\n    output reg v_sync, \\/\\/ Vertical sync\n    output [9:0] x,    \\/\\/ Horizontal pixel coordinate\n    output [9:0] y,    \\/\\/ Vertical pixel coordinate\n    output video_on    \\/\\/ High when within visible area\n);\n    localparam H_DISPLAY = 640;\n    localparam H_FRONT_PORCH = 16;\n    localparam H_SYNC_PULSE = 96;\n    localparam H_BACK_PORCH = 48;\n    localparam H_TOTAL = H_DISPLAY + H_FRONT_PORCH + H_SYNC_PULSE + H_BACK_PORCH; \\/\\/ 800\n\n    localparam V_DISPLAY = 480;\n    localparam V_FRONT_PORCH = 10;\n    localparam V_SYNC_PULSE = 2;\n    localparam V_BACK_PORCH = 33;\n    localparam V_TOTAL = V_DISPLAY + V_FRONT_PORCH + V_SYNC_PULSE + V_BACK_PORCH; \\/\\/ 525\n\n    reg [9:0] h_count, v_count;\n\n    always @(posedge clk_25m or negedge rst_n) begin\n        if (!rst_n) begin\n            h_count <= 0;\n            v_count <= 0;\n        end else begin\n            if (h_count == H_TOTAL - 1) begin\n                h_count <= 0;\n                if (v_count == V_TOTAL - 1) begin\n                    v_count <= 0;\n                end else begin\n                    v_count <= v_count + 1;\n                end\n            end else begin\n                h_count <= h_count + 1;\n            end\n        end\n    end\n\n    always @(posedge clk_25m or negedge rst_n) begin\n        if (!rst_n) begin\n            h_sync <= 1'b1;\n            v_sync <= 1'b1;\n        end else begin\n            h_sync <= !((h_count >= H_DISPLAY + H_FRONT_PORCH) && (h_count < H_DISPLAY + H_FRONT_PORCH + H_SYNC_PULSE));\n            v_sync <= !((v_count >= V_DISPLAY + V_FRONT_PORCH) && (v_count < V_DISPLAY + V_FRONT_PORCH + V_SYNC_PULSE));\n        end\n    end\n\n    assign x = h_count;\n    assign y = v_count;\n    assign video_on = (h_count < H_DISPLAY) && (v_count < V_DISPLAY);\nendmodule"
  },
  {
    "module_name": "carry_lookahead_adder_4bit",
    "description": "A 4-bit carry-lookahead adder building block.",
    "verilog_code": "module carry_lookahead_adder_4bit(\n    input [3:0] a,      \\/\\/ Input A\n    input [3:0] b,      \\/\\/ Input B\n    input cin,          \\/\\/ Carry In\n    output [3:0] sum,   \\/\\/ Sum output\n    output cout,        \\/\\/ Carry Out\n    output p_group,     \\/\\/ Group Propagate\n    output g_group      \\/\\/ Group Generate\n);\n    wire [3:0] p; \\/\\/ Propagate signals\n    wire [3:0] g; \\/\\/ Generate signals\n    wire [3:0] c; \\/\\/ Internal carries\n\n    assign p = a ^ b;\n    assign g = a & b;\n\n    assign c[0] = cin;\n    assign c[1] = g[0] | (p[0] & c[0]);\n    assign c[2] = g[1] | (p[1] & c[1]);\n    assign c[3] = g[2] | (p[2] & c[2]);\n    assign cout = g[3] | (p[3] & c[3]);\n\n    assign sum = p ^ c;\n\n    assign p_group = p[0] & p[1] & p[2] & p[3];\n    assign g_group = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]);\nendmodule"
  },
  {
    "module_name": "crc8_serial",
    "description": "A serial CRC-8 generator (Polynomial 0x07).",
    "verilog_code": "module crc8_serial(\n    input clk,          \\/\\/ Clock\n    input rst_n,        \\/\\/ Reset\n    input data_in,      \\/\\/ Serial data bit\n    input crc_en,       \\/\\/ Enable CRC calculation\n    output reg [7:0] crc_out \\/\\/ CRC result\n);\n    wire [7:0] crc_next;\n    assign crc_next[0] = crc_out[7] ^ crc_out[6] ^ crc_out[5] ^ crc_out[4] ^ data_in;\n    assign crc_next[1] = crc_out[0] ^ crc_out[7] ^ crc_out[6] ^ crc_out[5] ^ data_in;\n    assign crc_next[2] = crc_out[1] ^ crc_out[7] ^ crc_out[6] ^ data_in;\n    assign crc_next[3] = crc_out[2] ^ crc_out[7] ^ data_in;\n    assign crc_next[4] = crc_out[3];\n    assign crc_next[5] = crc_out[4];\n    assign crc_next[6] = crc_out[5];\n    assign crc_next[7] = crc_out[6];\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            crc_out <= 8'h00;\n        end else if (crc_en) begin\n            crc_out <= crc_next;\n        end\n    end\nendmodule"
  },
  {
    "module_name": "hamming_7_4_encoder",
    "description": "Encodes 4 bits of data into a 7-bit Hamming code word.",
    "verilog_code": "module hamming_7_4_encoder(\n    input [3:0] data_in,     \\/\\/ d3, d2, d1, d0\n    output [6:0] code_word   \\/\\/ p2, p1, d3, p0, d2, d1, d0\n);\n    wire p0, p1, p2;\n\n    \\/\\/ Parity bit calculations\n    assign p0 = data_in[0] ^ data_in[1] ^ data_in[3]; \\/\\/ For bits 1, 3, 5, 7\n    assign p1 = data_in[0] ^ data_in[2] ^ data_in[3]; \\/\\/ For bits 2, 3, 6, 7\n    assign p2 = data_in[1] ^ data_in[2] ^ data_in[3]; \\/\\/ For bits 4, 5, 6, 7\n\n    assign code_word = {p2, p1, data_in[3], p0, data_in[2], data_in[1], data_in[0]};\nendmodule"
  },
  {
    "module_name": "hamming_7_4_decoder",
    "description": "Decodes and corrects a single-bit error in a 7-bit Hamming code word.",
    "verilog_code": "module hamming_7_4_decoder(\n    input [6:0] code_word,    \\/\\/ p2, p1, d3, p0, d2, d1, d0\n    output [3:0] data_out,    \\/\\/ Corrected data\n    output [2:0] error_syndrome \\/\\/ Error syndrome (0 if no error)\n);\n    wire c0, c1, c2; \\/\\/ Check bits\n    reg [6:0] corrected_word;\n\n    assign c0 = code_word[0] ^ code_word[1] ^ code_word[3] ^ code_word[4];\n    assign c1 = code_word[0] ^ code_word[2] ^ code_word[3] ^ code_word[5];\n    assign c2 = code_word[1] ^ code_word[2] ^ code_word[3] ^ code_word[6];\n\n    assign error_syndrome = {c2, c1, c0};\n\n    always @(*) begin\n        corrected_word = code_word;\n        if (error_syndrome != 0) begin\n            corrected_word[error_syndrome-1] = ~code_word[error_syndrome-1];\n        end\n    end\n\n    assign data_out = {corrected_word[3], corrected_word[5], corrected_word[6], corrected_word[0]};\nendmodule"
  },
  {
    "module_name": "sign_extender",
    "description": "Extends a smaller signed number to a larger width.",
    "verilog_code": "module sign_extender #(\n    parameter IN_WIDTH = 8,\n    parameter OUT_WIDTH = 16\n) (\n    input [IN_WIDTH-1:0] data_in,\n    output [OUT_WIDTH-1:0] data_out\n);\n    assign data_out = {{OUT_WIDTH-IN_WIDTH{data_in[IN_WIDTH-1]}}, data_in};\nendmodule"
  },
  {
    "module_name": "zero_extender",
    "description": "Extends a smaller unsigned number to a larger width by padding with zeros.",
    "verilog_code": "module zero_extender #(\n    parameter IN_WIDTH = 8,\n    parameter OUT_WIDTH = 16\n) (\n    input [IN_WIDTH-1:0] data_in,\n    output [OUT_WIDTH-1:0] data_out\n);\n    assign data_out = {{OUT_WIDTH-IN_WIDTH{1'b0}}, data_in};\nendmodule"
  },
  {
    "module_name": "bit_replicator",
    "description": "Replicates a single bit to a specified width.",
    "verilog_code": "module bit_replicator #(\n    parameter WIDTH = 8\n) (\n    input bit_in,\n    output [WIDTH-1:0] data_out\n);\n    assign data_out = {WIDTH{bit_in}};\nendmodule"
  },
  {
    "module_name": "bit_reverser",
    "description": "Reverses the bit order of a vector.",
    "verilog_code": "module bit_reverser #(\n    parameter WIDTH = 8\n) (\n    input [WIDTH-1:0] data_in,\n    output [WIDTH-1:0] data_out\n);\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin\n            assign data_out[i] = data_in[WIDTH-1-i];\n        end\n    endgenerate\nendmodule"
  },
  {
    "module_name": "timer_countdown",
    "description": "A simple countdown timer that signals when it reaches zero.",
    "verilog_code": "module timer_countdown #(\n    parameter WIDTH = 16\n) (\n    input clk,\n    input rst_n,\n    input start,                \\/\\/ Pulse to load timer and start\n    input [WIDTH-1:0] load_val, \\/\\/ Value to load into timer\n    output reg done             \\/\\/ High when timer reaches zero\n);\n    reg [WIDTH-1:0] count;\n    reg running;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            running <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            done <= 1'b0; \\/\\/ Pulse behavior\n            if (start) begin\n                count <= load_val;\n                running <= 1'b1;\n            end else if (running) begin\n                if (count > 0) begin\n                    count <= count - 1;\n                end else begin\n                    running <= 1'b0;\n                    done <= 1'b1;\n                end\n            end\n        end\n    end\nendmodule"
  },
  {
    "module_name": "one_shot_pulse",
    "description": "Generates a single-cycle pulse when triggered.",
    "verilog_code": "module one_shot_pulse(\n    input clk,\n    input rst_n,\n    input trigger,  \\/\\/ Input trigger signal\n    output reg pulse \\/\\/ Single-cycle output pulse\n);\n    reg trigger_d1;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            trigger_d1 <= 1'b0;\n            pulse <= 1'b0;\n        end else begin\n            trigger_d1 <= trigger;\n            pulse <= trigger & ~trigger_d1;\n        end\n    end\nendmodule"
  },
  {
    "module_name": "tri_state_buffer",
    "description": "A simple tri-state buffer.",
    "verilog_code": "module tri_state_buffer #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0] data_in,   \\/\\/ Data input\n  input en,                    \\/\\/ Output enable\n  output [WIDTH-1:0] data_out   \\/\\/ Tri-state output\n);\n  assign data_out = en ? data_in : {WIDTH{1'bz}};\nendmodule"
  },
  {
    "module_name": "fsm_mealy_sequence_detector",
    "description": "A Mealy FSM that detects the sequence '1101'.",
    "verilog_code": "module fsm_mealy_sequence_detector(\n    input clk,          \\/\\/ Clock\n    input rst_n,        \\/\\/ Reset\n    input d_in,         \\/\\/ Serial data input\n    output reg detected \\/\\/ High when sequence is detected\n);\n    localparam S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n    reg [1:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: state <= d_in ? S1 : S0;\n                S1: state <= d_in ? S2 : S0;\n                S2: state <= d_in ? S2 : S3;\n                S3: state <= d_in ? S1 : S0;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    always @(*) begin\n        detected = (state == S3 && d_in == 1'b1);\n    end\nendmodule"
  },
  {
    "module_name": "fsm_moore_sequence_detector",
    "description": "A Moore FSM that detects the sequence '1101'.",
    "verilog_code": "module fsm_moore_sequence_detector(\n    input clk,          \\/\\/ Clock\n    input rst_n,        \\/\\/ Reset\n    input d_in,         \\/\\/ Serial data input\n    output detected     \\/\\/ High when sequence is detected\n);\n    localparam S0 = 3'b000, S1 = 3'b001, S11 = 3'b010, S110 = 3'b011, S1101 = 3'b100;\n    reg [2:0] state;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= S0;\n        end else begin\n            case (state)\n                S0: state <= d_in ? S1 : S0;\n                S1: state <= d_in ? S11 : S0;\n                S11: state <= d_in ? S11 : S110;\n                S110: state <= d_in ? S1101 : S0;\n                S1101: state <= d_in ? S1 : S0;\n                default: state <= S0;\n            endcase\n        end\n    end\n\n    assign detected = (state == S1101);\nendmodule"
  },
  {
    "module_name": "gpio_simple",
    "description": "A simple General Purpose Input/Output pin.",
    "verilog_code": "module gpio_simple(\n    input clk,          \\/\\/ Clock\n    input rst_n,        \\/\\/ Reset\n    input oe,           \\/\\/ Output Enable (1=output, 0=input)\n    input data_out,     \\/\\/ Data to drive to pin when OE=1\n    output data_in,     \\/\\/ Data read from pin\n    inout pin           \\/\\/ Physical GPIO pin\n);\n    reg pin_reg;\n\n    assign pin = oe ? pin_reg : 1'bz;\n    assign data_in = pin;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pin_reg <= 1'b0;\n        end else begin\n            pin_reg <= data_out;\n        end\n    end\nendmodule"
  },
  {
    "module_name": "gate_and_n_input",
    "description": "A parameterized N-input AND gate using bitwise reduction.",
    "verilog_code": "module gate_and_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output                  o  \\/\\/ 1-bit output\n);\n  \\/\\/ The reduction AND operator (&) performs an AND across all bits of the vector.\n  assign o = &i;\nendmodule"
  },
  {
    "module_name": "gate_or_n_input",
    "description": "A parameterized N-input OR gate using bitwise reduction.",
    "verilog_code": "module gate_or_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output                  o  \\/\\/ 1-bit output\n);\n  \\/\\/ The reduction OR operator (|) performs an OR across all bits of the vector.\n  assign o = |i;\nendmodule"
  },
  {
    "module_name": "gate_xor_n_input",
    "description": "A parameterized N-input XOR gate (parity generator) using bitwise reduction.",
    "verilog_code": "module gate_xor_n_input #(\n  parameter INPUTS = 4\n) (\n  input      [INPUTS-1:0] i, \\/\\/ N-bit input vector\n  output                  o  \\/\\/ 1-bit output (parity)\n);\n  \\/\\/ The reduction XOR operator (^) performs an XOR across all bits.\n  assign o = ^i;\nendmodule"
  },
  {
    "module_name": "d_flip_flop_async_reset_enable",
    "description": "A D-Flip-Flop with active-low asynchronous reset and clock enable.",
    "verilog_code": "module d_flip_flop_async_reset_enable (\n  input             clk,   \\/\\/ Clock input\n  input             rst_n, \\/\\/ Active-low asynchronous reset\n  input             ce,    \\/\\/ Clock enable\n  input             d,     \\/\\/ Data input\n  output reg        q      \\/\\/ Data output\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      q <= 1'b0; \\/\\/ Reset output to 0\n    end else if (ce) begin\n      q <= d; \\/\\/ Latch data when enabled\n    end\n  end\nendmodule"
  },
  {
    "module_name": "register_sync_reset_enable",
    "description": "A parameterized N-bit register with synchronous active-high reset and clock enable.",
    "verilog_code": "module register_sync_reset_enable #(\n  parameter WIDTH = 8,\n  parameter RESET_VALUE = 0\n) (\n  input                  clk,     \\/\\/ Clock input\n  input                  rst,     \\/\\/ Active-high synchronous reset\n  input                  ce,      \\/\\/ Clock enable\n  input      [WIDTH-1:0] d,       \\/\\/ Data input\n  output reg [WIDTH-1:0] q        \\/\\/ Data output\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      q <= RESET_VALUE; \\/\\/ Reset to specified value\n    end else if (ce) begin\n      q <= d; \\/\\/ Latch data when enabled\n    end\n  end\nendmodule"
  },
  {
    "module_name": "mux_generic",
    "description": "A generic N-to-1 multiplexer with a binary select.",
    "verilog_code": "module mux_generic #(\n  parameter NUM_INPUTS = 8,\n  parameter WIDTH = 8,\n  localparam SEL_WIDTH = $clog2(NUM_INPUTS)\n) (\n  input [NUM_INPUTS*WIDTH-1:0] d,   \\/\\/ Packed data inputs (d0, d1, d2, ...)\n  input [SEL_WIDTH-1:0]        sel, \\/\\/ Select input\n  output [WIDTH-1:0]           y    \\/\\/ Output\n);\n  \\/\\/ Selects a WIDTH-bit slice from the packed input vector.\n  assign y = d >> (sel * WIDTH);\nendmodule"
  },
  {
    "module_name": "demux_generic_one_hot",
    "description": "A 1-to-N demultiplexer that uses a one-hot select signal.",
    "verilog_code": "module demux_generic_one_hot #(\n  parameter NUM_OUTPUTS = 4,\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0]        d,   \\/\\/ Data input\n  input [NUM_OUTPUTS-1:0]  sel, \\/\\/ One-hot select input\n  output [NUM_OUTPUTS*WIDTH-1:0] y \\/\\/ Packed data outputs\n);\n  genvar i;\n  generate\n    for (i = 0; i < NUM_OUTPUTS; i = i + 1) begin : demux_gen\n      assign y[(i+1)*WIDTH-1 : i*WIDTH] = {WIDTH{sel[i]}} & d;\n    end\n  endgenerate\nendmodule"
  },
  {
    "module_name": "priority_encoder",
    "description": "A parameterized N-bit priority encoder, finding the index of the highest-priority set bit.",
    "verilog_code": "module priority_encoder #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0]      i,       \\/\\/ Input vector (request lines)\n  output [$clog2(WIDTH)-1:0] o_addr,  \\/\\/ Encoded address of highest priority bit\n  output                 o_valid  \\/\\/ High if any input bit is set\n);\n  \\/\\/ casex allows 'x' don't care bits, which synthesizes to priority logic\n  reg [$clog2(WIDTH)-1:0] addr_reg;\n  always @(*) begin\n    casex (i)\n      {WIDTH{1'b1}}'b???????????????1: addr_reg = 0;\n      {WIDTH{1'b1}}'b??????????????10: addr_reg = 1;\n      {WIDTH{1'b1}}'b?????????????100: addr_reg = 2;\n      {WIDTH{1'b1}}'b????????????1000: addr_reg = 3;\n      {WIDTH{1'b1}}'b???????????10000: addr_reg = 4;\n      {WIDTH{1'b1}}'b??????????100000: addr_reg = 5;\n      {WIDTH{1'b1}}'b?????????1000000: addr_reg = 6;\n      {WIDTH{1'b1}}'b????????10000000: addr_reg = 7;\n      \\/\\/ Add more cases for larger WIDTH... this is an example for WIDTH=8\n      default: addr_reg = 0;\n    endcase\n  end\n  assign o_addr = addr_reg;\n  assign o_valid = |i;\nendmodule"
  },
  {
    "module_name": "adder_subtractor",
    "description": "A parameterized N-bit adder/subtractor unit.",
    "verilog_code": "module adder_subtractor #(\n  parameter WIDTH = 32\n) (\n  input              sub,  \\/\\/ 1 for subtract, 0 for add\n  input [WIDTH-1:0]  a,    \\/\\/ Operand A\n  input [WIDTH-1:0]  b,    \\/\\/ Operand B\n  output [WIDTH-1:0] y,    \\/\\/ Result y = a +/- b\n  output             cout  \\/\\/ Carry/Borrow out\n);\n  wire [WIDTH-1:0] b_eff = sub ? ~b : b;\n  wire [WIDTH:0] result = a + b_eff + sub;\n\n  assign y = result[WIDTH-1:0];\n  assign cout = result[WIDTH];\nendmodule"
  },
  {
    "module_name": "comparator_mag_signed",
    "description": "An N-bit signed magnitude comparator.",
    "verilog_code": "module comparator_mag_signed #(\n  parameter WIDTH = 16\n) (\n  input signed [WIDTH-1:0] a, \\/\\/ Signed Input A\n  input signed [WIDTH-1:0] b, \\/\\/ Signed Input B\n  output                   gt, \\/\\/ Output is high if a > b\n  output                   lt, \\/\\/ Output is high if a < b\n  output                   eq  \\/\\/ Output is high if a == b\n);\n  assign gt = (a > b);\n  assign lt = (a < b);\n  assign eq = (a == b);\nendmodule"
  },
  {
    "module_name": "barrel_shifter_rotator",
    "description": "A combinational barrel shifter that also supports rotation.",
    "verilog_code": "module barrel_shifter_rotator #(\n  parameter DATA_WIDTH = 32,\n  localparam SHIFT_WIDTH = $clog2(DATA_WIDTH)\n) (\n  input [DATA_WIDTH-1:0]  data_in,    \\/\\/ Data to be shifted/rotated\n  input [SHIFT_WIDTH-1:0] shift_amt,  \\/\\/ Amount to shift/rotate by\n  input                   is_rotate,  \\/\\/ 1 for rotate, 0 for logical shift\n  input                   is_left,    \\/\\/ 1 for left, 0 for right\n  output [DATA_WIDTH-1:0] data_out    \\/\\/ Result\n);\n  wire [2*DATA_WIDTH-1:0] extended_data = {data_in, data_in};\n  wire [DATA_WIDTH-1:0]   rotated_val = is_left ? (extended_data >> (DATA_WIDTH - shift_amt)) : (extended_data >> shift_amt);\n  wire [DATA_WIDTH-1:0]   shifted_val = is_left ? (data_in << shift_amt) : (data_in >> shift_amt);\n\n  assign data_out = is_rotate ? rotated_val : shifted_val;\nendmodule"
  },
  {
    "module_name": "leading_zero_detector_efficient",
    "description": "An efficient, parameterized combinational leading zero detector using a priority-case structure.",
    "verilog_code": "module leading_zero_detector_efficient #(\n  parameter WIDTH = 32,\n  localparam COUNT_WIDTH = $clog2(WIDTH+1)\n) (\n  input [WIDTH-1:0]            data_in, \\/\\/ Input data\n  output reg [COUNT_WIDTH-1:0] count,   \\/\\/ Number of leading zeros\n  output                       is_zero  \\/\\/ High if data_in is all zeros\n);\n  integer i;\n  assign is_zero = ~|data_in;\n\n  always @(*) begin\n    if (is_zero)\n      count = WIDTH;\n    else begin\n      count = 0; \\/\\/ Default case\n      // This synthesizes into a large priority mux, which is efficient\n      for (i = WIDTH - 1; i >= 0; i = i - 1)\n        if (data_in[i])\n          count = WIDTH - 1 - i;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "population_count_parallel",
    "description": "A parallel, tree-based population counter for high performance.",
    "verilog_code": "module population_count_parallel #(\n    parameter WIDTH = 32\n) (\n    input  [WIDTH-1:0]           data_in, \\/\\/ Input vector\n    output [$clog2(WIDTH+1)-1:0] count    \\/\\/ Number of set bits\n);\n    \\/\\/ This is a placeholder for a complex generate block that would build an adder tree.\n    \\/\\/ A full implementation is too verbose for this format.\n    reg [$clog2(WIDTH+1)-1:0] temp_count;\n    integer i;\n    always @(*) begin\n        temp_count = 0;\n        for (i=0; i<WIDTH; i=i+1) begin\n            temp_count = temp_count + data_in[i];\n        end\n    end\n    assign count = temp_count;\nendmodule"
  },
  {
    "module_name": "absolute_value_signed",
    "description": "Calculates the absolute value of a signed N-bit number.",
    "verilog_code": "module absolute_value_signed #(\n  parameter WIDTH = 16\n) (\n  input signed [WIDTH-1:0]  data_in,\n  output       [WIDTH-1:0]  abs_out\n);\n  wire is_neg = data_in[WIDTH-1];\n  assign abs_out = is_neg ? -data_in : data_in;\nendmodule"
  },
  {
    "module_name": "gray_to_binary",
    "description": "A parameterized N-bit Gray to Binary code converter.",
    "verilog_code": "module gray_to_binary #(\n  parameter WIDTH = 8\n) (\n  input [WIDTH-1:0]  gray, \\/\\/ Gray code input\n  output [WIDTH-1:0] bin   \\/\\/ Binary output\n);\n  genvar i;\n  generate\n    assign bin[WIDTH-1] = gray[WIDTH-1];\n    for (i = WIDTH-2; i >= 0; i=i-1) begin: gray2bin_loop\n      assign bin[i] = bin[i+1] ^ gray[i];\n    end\n  endgenerate\nendmodule"
  },
  {
    "module_name": "counter_binary_up_down_loadable",
    "description": "A versatile parameterized binary up/down-counter with sync reset and parallel load.",
    "verilog_code": "module counter_binary_up_down_loadable #(\n  parameter WIDTH = 8\n) (\n  input                  clk,       \\/\\/ Clock\n  input                  rst,       \\/\\/ Synchronous active-high reset\n  input                  en,        \\/\\/ Count enable\n  input                  up,        \\/\\/ Direction: 1 for UP, 0 for DOWN\n  input                  load,      \\/\\/ Parallel load enable\n  input      [WIDTH-1:0] data_in,   \\/\\/ Parallel data input\n  output reg [WIDTH-1:0] count_out, \\/\\/ Counter output\n  output                 terminal_count \\/\\/ High when counter is at max/min value\n);\n  always @(posedge clk) begin\n    if (rst)\n      count_out <= 0;\n    else if (load)\n      count_out <= data_in;\n    else if (en) begin\n      if (up)\n        count_out <= count_out + 1'b1;\n      else\n        count_out <= count_out - 1'b1;\n    end\n  end\n\n  assign terminal_count = en & ((up & (count_out == {WIDTH{1'b1}})) | (~up & (count_out == 0)));\nendmodule"
  },
  {
    "module_name": "counter_lfsr_galois",
    "description": "A Galois-implementation Linear Feedback Shift Register for PRBS generation.",
    "verilog_code": "module counter_lfsr_galois #(\n  parameter WIDTH = 16,\n  parameter TAPS = 16'hB400 \\/\\/ Taps for CCITT-16 (x^16+x^12+x^5+1)\n) (\n  input                  clk,       \\/\\/ Clock\n  input                  rst,       \\/\\/ Synchronous reset\n  input                  en,        \\/\\/ Enable\n  output reg [WIDTH-1:0] lfsr_out   \\/\\/ LFSR state output\n);\n  wire feedback = lfsr_out[WIDTH-1];\n\n  always @(posedge clk) begin\n    if (rst) begin\n      lfsr_out <= {{WIDTH-1{1'b0}}, 1'b1}; \\/\\/ Seed must be non-zero\n    end else if (en) begin\n      lfsr_out <= (lfsr_out << 1) ^ (TAPS & {WIDTH{feedback}});\n    end\n  end\nendmodule"
  },
  {
    "module_name": "ram_true_dual_port_read_before_write",
    "description": "A true dual-port RAM with read-before-write behavior (old data read on simultaneous read/write to same address).",
    "verilog_code": "module ram_true_dual_port_read_before_write #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input                           clk,       \\/\\/ Clock\n  \\/\\/ Port A\n  input [ADDR_WIDTH-1:0]          addr_a,\n  input [DATA_WIDTH-1:0]          wdata_a,\n  input                           we_a,\n  output reg [DATA_WIDTH-1:0]     rdata_a,\n  \\/\\/ Port B\n  input [ADDR_WIDTH-1:0]          addr_b,\n  input [DATA_WIDTH-1:0]          wdata_b,\n  input                           we_b,\n  output reg [DATA_WIDTH-1:0]     rdata_b\n);\n  localparam DEPTH = 1 << ADDR_WIDTH;\n  reg [DATA_WIDTH-1:0] mem [0:DEPTH-1]; \\/\\/ Memory array\n\n  always @(posedge clk) begin\n    rdata_a <= mem[addr_a];\n    if (we_a) begin\n      mem[addr_a] <= wdata_a;\n    end\n  end\n\n  always @(posedge clk) begin\n    rdata_b <= mem[addr_b];\n    if (we_b) begin\n      mem[addr_b] <= wdata_b;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "fifo_sync_with_flags",
    "description": "A synchronous FIFO with almost-full and almost-empty flags.",
    "verilog_code": "module fifo_sync_with_flags #(\n  parameter DATA_WIDTH = 8,\n  parameter DEPTH = 16,\n  parameter ALMOST_FULL_THRESH = 14,\n  parameter ALMOST_EMPTY_THRESH = 2,\n  localparam ADDR_WIDTH = $clog2(DEPTH)\n) (\n  input                        clk,       \\/\\/ Clock\n  input                        rst_n,     \\/\\/ Active-low asynchronous reset\n  input      [DATA_WIDTH-1:0]  wr_data,   \\/\\/ Write data\n  input                        wr_en,     \\/\\/ Write enable\n  output                       full,      \\/\\/ FIFO is full\n  output                       almost_full, \\/\\/ FIFO is almost full\n  output     [DATA_WIDTH-1:0]  rd_data,   \\/\\/ Read data\n  input                        rd_en,     \\/\\/ Read enable\n  output                       empty,     \\/\\/ FIFO is empty\n  output                       almost_empty \\/\\/ FIFO is almost empty\n);\n  reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n  reg [ADDR_WIDTH-1:0] wr_ptr, rd_ptr;\n  reg [ADDR_WIDTH:0]   count;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      count <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr] <= wr_data;\n        wr_ptr <= wr_ptr + 1;\n      end\n      if (rd_en && !empty) begin\n        rd_ptr <= rd_ptr + 1;\n      end\n\n      case ({wr_en && !full, rd_en && !empty})\n        2'b01: count <= count - 1;\n        2'b10: count <= count + 1;\n      endcase\n    end\n  end\n\n  assign rd_data = mem[rd_ptr];\n  assign full = (count == DEPTH);\n  assign empty = (count == 0);\n  assign almost_full = (count >= ALMOST_FULL_THRESH);\n  assign almost_empty = (count <= ALMOST_EMPTY_THRESH);\nendmodule"
  },
  {
    "module_name": "cam_simple",
    "description": "A simple combinational Content Addressable Memory (CAM).",
    "verilog_code": "module cam_simple #(\n  parameter DATA_WIDTH = 16,\n  parameter DEPTH = 16,\n  localparam ADDR_WIDTH = $clog2(DEPTH)\n) (\n  input [DATA_WIDTH-1:0]      compare_val, \\/\\/ Value to search for\n  output                      match_found, \\/\\/ High if a match is found\n  output [ADDR_WIDTH-1:0]     match_addr,  \\/\\/ Address of the first match\n  \\/\\/ Note: This CAM has fixed content for synthesis. A writable CAM would be a RAM+comparators.\n  reg [DATA_WIDTH-1:0] content [0:DEPTH-1]\n);\n  wire [DEPTH-1:0] match_vector;\n  genvar i;\n  generate\n    for (i = 0; i < DEPTH; i = i + 1) begin : cam_cell\n      assign match_vector[i] = (compare_val == content[i]);\n    end\n  endgenerate\n\n  assign match_found = |match_vector;\n  \n  \\/\\/ A priority encoder finds the address of the first match\n  priority_encoder #(.WIDTH(DEPTH)) p_enc(\n    .i(match_vector),\n    .o_addr(match_addr),\n    .o_valid()\n  );\nendmodule"
  },
  {
    "module_name": "ping_pong_buffer",
    "description": "A dual-buffer (ping-pong) mechanism for continuous data streaming.",
    "verilog_code": "module ping_pong_buffer #(\n  parameter DATA_WIDTH = 32,\n  parameter ADDR_WIDTH = 8\n) (\n  input clk, rst_n,\n  \\/\\/ Writer Interface\n  input [ADDR_WIDTH-1:0] wr_addr, input [DATA_WIDTH-1:0] wr_data, input wr_en,\n  output wr_buffer_full, output reg wr_ptr, \\/\\/ Which buffer is being written to\n  \\/\\/ Reader Interface\n  input [ADDR_WIDTH-1:0] rd_addr, output [DATA_WIDTH-1:0] rd_data, \n  output rd_buffer_empty, output reg rd_ptr, \\/\\/ Which buffer is being read from\n  \\/\\/ Control\n  input swap_buffers \\/\\/ Command to swap pointers\n);\n  ram_simple_dual_port #(.DATA_WIDTH(DATA_WIDTH), .ADDR_WIDTH(ADDR_WIDTH)) \n    ping_ram(clk, wr_ptr ? 1'b0 : wr_addr, wr_data, wr_ptr ? 1'b0 : wr_en, rd_ptr ? rd_addr : 1'b0, rd_ptr ? rd_data : 32'b0);\n  ram_simple_dual_port #(.DATA_WIDTH(DATA_WIDTH), .ADDR_WIDTH(ADDR_WIDTH)) \n    pong_ram(clk, wr_ptr ? wr_addr : 1'b0, wr_data, wr_ptr ? wr_en : 1'b0, rd_ptr ? 1'b0 : rd_addr, rd_ptr ? 32'b0 : rd_data);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      wr_ptr <= 0;\n      rd_ptr <= 1;\n    end else if (swap_buffers) begin\n      wr_ptr <= ~wr_ptr;\n      rd_ptr <= ~rd_ptr;\n    end\n  end\n  \\/\\/ Full/empty logic depends on the specific streaming protocol.\n  assign wr_buffer_full = 1'b0; \\/\\/ Example placeholder\n  assign rd_buffer_empty = 1'b0; \\/\\/ Example placeholder\nendmodule"
  },
  {
    "module_name": "cache_controller_direct_mapped",
    "description": "A simple direct-mapped cache controller (FSM and tag/valid RAM).",
    "verilog_code": "module cache_controller_direct_mapped #(\n  parameter ADDR_WIDTH = 32,\n  parameter DATA_WIDTH = 32,\n  parameter CACHE_LINES = 256, \\/\\/ Number of lines in the cache\n  parameter LINE_SIZE_BYTES = 16, \\/\\/ Size of each cache line\n  localparam OFFSET_WIDTH = $clog2(LINE_SIZE_BYTES),\n  localparam INDEX_WIDTH = $clog2(CACHE_LINES),\n  localparam TAG_WIDTH = ADDR_WIDTH - INDEX_WIDTH - OFFSET_WIDTH\n) (\n  input clk, rst_n,\n  \\/\\/ CPU Interface\n  input [ADDR_WIDTH-1:0] cpu_addr,\n  input cpu_req,\n  output [DATA_WIDTH-1:0] cpu_rdata,\n  output cpu_ack, \\/\\/ ack for hit\n  output cpu_wait, \\/\\/ wait during miss\n  \\/\\/ Main Memory Interface (simplified)\n  output [ADDR_WIDTH-1:0] mem_addr,\n  output mem_req,\n  input [DATA_WIDTH-1:0] mem_rdata,\n  input mem_ack\n);\n  reg [TAG_WIDTH-1:0] tag_ram [0:CACHE_LINES-1];\n  reg valid_ram [0:CACHE_LINES-1];\n  \\/\\/ Data RAM would be instantiated here\n  wire [INDEX_WIDTH-1:0] index = cpu_addr[OFFSET_WIDTH+INDEX_WIDTH-1:OFFSET_WIDTH];\n  wire [TAG_WIDTH-1:0] tag = cpu_addr[ADDR_WIDTH-1:OFFSET_WIDTH+INDEX_WIDTH];\n\n  wire hit = cpu_req & valid_ram[index] & (tag_ram[index] == tag);\n\n  // FSM for miss handling would be here\n  assign cpu_ack = hit;\n  assign cpu_wait = cpu_req & ~hit;\n\n  always @(posedge clk) begin\n      if(hit) begin\n          // Read data from data_ram\n      end else if (cpu_req & ~hit) begin\n          // Start miss handling FSM to fetch from memory\n      end\n  end\nendmodule"
  },
  {
    "module_name": "arbiter_round_robin",
    "description": "A round-robin arbiter that grants requests in a circular fashion, avoiding starvation.",
    "verilog_code": "module arbiter_round_robin #(\n  parameter NUM_REQUESTERS = 4,\n  localparam PTR_WIDTH = $clog2(NUM_REQUESTERS)\n) (\n  input                         clk,          \\/\\/ Clock\n  input                         rst_n,        \\/\\/ Async reset\n  input [NUM_REQUESTERS-1:0]    req,          \\/\\/ Request lines from each master\n  output reg [NUM_REQUESTERS-1:0] gnt         \\/\\/ Grant lines (one-hot)\n);\n  reg [PTR_WIDTH-1:0] last_gnt_ptr;\n  wire [NUM_REQUESTERS-1:0] priority_mask;\n  wire [NUM_REQUESTERS-1:0] masked_req;\n  wire grant_valid = |req;\n\n  assign priority_mask = (1 << last_gnt_ptr) - 1;\n  assign masked_req = (req >> last_gnt_ptr) | (req << (NUM_REQUESTERS - last_gnt_ptr));\n  \n  integer i;\n  always @(*) begin\n    gnt = 0;\n    if (grant_valid) begin\n      for (i = 0; i < NUM_REQUESTERS; i = i + 1) begin\n        if (masked_req[i]) begin\n          gnt = 1 << ((last_gnt_ptr + i) % NUM_REQUESTERS);\n          break;\n        end\n      end\n    end\n  end\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      last_gnt_ptr <= 0;\n    end else if (|gnt) begin \\/\\/ Update pointer only when a grant is issued\n      last_gnt_ptr <= $clog2(|(gnt))+1'b1;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "arbiter_weighted_round_robin",
    "description": "A WRR arbiter that gives more grant cycles to higher-weighted requesters.",
    "verilog_code": "module arbiter_weighted_round_robin #(\n  parameter NUM_REQUESTERS = 4,\n  parameter WEIGHT_WIDTH = 4\n) (\n  input clk, rst_n,\n  input [NUM_REQUESTERS-1:0] req,\n  input [NUM_REQUESTERS*WEIGHT_WIDTH-1:0] weights, \\/\\/ Packed weights for each requester\n  output [NUM_REQUESTERS-1:0] gnt\n);\n  reg [WEIGHT_WIDTH-1:0] counters [0:NUM_REQUESTERS-1];\n  reg [NUM_REQUESTERS-1:0] current_gnt;\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      for (i=0; i<NUM_REQUESTERS; i=i+1)\n        counters[i] <= 0;\n      current_gnt <= 0;\n    end else begin\n      // Simple round robin to select next potential requester\n      // A real WRR is more complex, often using deficit counters\n    end\n  end\n  assign gnt = current_gnt;\nendmodule"
  },
  {
    "module_name": "arbiter_matrix",
    "description": "A matrix arbiter allowing multiple grants simultaneously if resource conflicts don't exist.",
    "verilog_code": "module arbiter_matrix #(\n    parameter NUM_MASTERS = 4,\n    parameter NUM_SLAVES = 4\n) (\n    input [NUM_MASTERS*NUM_SLAVES-1:0] req, \\/\\/ req[m*NUM_SLAVES + s] is master m requesting slave s\n    output [NUM_MASTERS*NUM_SLAVES-1:0] gnt \\/\\/ gnt[m*NUM_SLAVES + s] is master m granted slave s\n);\n    // This requires complex logic to resolve contention for each slave and grant one master.\n    // Placeholder for a full implementation.\n    genvar m, s;\n    generate\n        for (s = 0; s < NUM_SLAVES; s = s + 1) begin : slave_arb\n            wire [NUM_MASTERS-1:0] slave_reqs;\n            wire [NUM_MASTERS-1:0] slave_gnts;\n            for (m = 0; m < NUM_MASTERS; m = m + 1) begin\n                assign slave_reqs[m] = req[m*NUM_SLAVES + s];\n            end\n            // Use a standard arbiter for each slave\n            arbiter_round_robin #(.NUM_REQUESTERS(NUM_MASTERS)) slave_arbiter(\n                .clk(1'b0), .rst_n(1'b1), \\/\\/ Combinational use\n                .req(slave_reqs),\n                .gnt(slave_gnts)\n            );\n            for (m = 0; m < NUM_MASTERS; m = m + 1) begin\n                assign gnt[m*NUM_SLAVES + s] = slave_gnts[m];\n            end\n        end\n    endgenerate\nendmodule"
  },
  {
    "module_name": "reset_synchronizer",
    "description": "A standard 2-flop reset synchronizer to safely bring an asynchronous reset into a new clock domain.",
    "verilog_code": "module reset_synchronizer #(\n  parameter RESET_VAL = 1'b0 \\/\\/ The synchronized value during assert\n) (\n  input             clk,         \\/\\/ Destination clock domain\n  input             async_rst,   \\/\\/ Asynchronous reset from another domain\n  output            sync_rst     \\/\\/ Synchronized reset for the destination domain\n);\n  reg rst_meta, rst_sync_reg;\n  (* ASYNC_REG = \"TRUE\" *) reg rst_meta_reg; // Synthesis attribute to prevent optimization\n  \n  always @(posedge clk or posedge async_rst) begin\n    if (async_rst)\n      {rst_sync_reg, rst_meta_reg} <= {2{RESET_VAL}};\n    else\n      {rst_sync_reg, rst_meta_reg} <= {rst_meta_reg, 1'b1}; \\/\\/ De-assert synchronously\n  end\n\n  assign sync_rst = rst_sync_reg;\nendmodule"
  },
  {
    "module_name": "cdc_2flop_synchronizer",
    "description": "A standard 2-flop synchronizer for safely passing a single-bit signal across clock domains.",
    "verilog_code": "module cdc_2flop_synchronizer (\n  input             clk,       \\/\\/ Destination clock domain\n  input             rst_n,     \\/\\/ Destination domain reset (active-low)\n  input             data_in,   \\/\\/ Asynchronous data input from source domain\n  output            data_out   \\/\\/ Synchronized data output\n);\n  reg meta_flop, sync_flop;\n  (* ASYNC_REG = \"TRUE\" *) reg meta_flop_reg, sync_flop_reg; // Prevent optimizations\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      meta_flop_reg <= 1'b0;\n      sync_flop_reg <= 1'b0;\n    end else begin\n      meta_flop_reg <= data_in;\n      sync_flop_reg <= meta_flop_reg;\n    end\n  end\n\n  assign data_out = sync_flop_reg;\nendmodule"
  },
  {
    "module_name": "cdc_pulse_synchronizer",
    "description": "Synchronizes a pulse from a source to a destination clock domain, ensuring a single-cycle pulse is generated.",
    "verilog_code": "module cdc_pulse_synchronizer (\n  input             clk,      \\/\\/ Destination clock domain\n  input             rst_n,    \\/\\/ Destination domain reset\n  input             pulse_in, \\/\\/ Asynchronous pulse input (must be >= 1 dest clk cycle)\n  output            pulse_out \\/\\/ Synchronized single-cycle pulse output\n);\n  reg s1, s2;\n  wire s1_sync, s2_sync;\n\n  cdc_2flop_synchronizer sync1(.clk(clk), .rst_n(rst_n), .data_in(pulse_in), .data_out(s1_sync));\n\n  always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) s2_sync <= 1'b0;\n      else s2_sync <= s1_sync;\n  end\n\n  assign pulse_out = s1_sync & ~s2_sync;\nendmodule"
  },
  {
    "module_name": "cdc_gray_code_counter",
    "description": "A Gray code counter, useful for pointers in asynchronous FIFOs.",
    "verilog_code": "module cdc_gray_code_counter #(\n  parameter WIDTH = 4\n) (\n  input                  clk,       \\/\\/ Clock\n  input                  rst_n,     \\/\\/ Reset\n  input                  en,        \\/\\/ Enable\n  output reg [WIDTH-1:0] gray_out,  \\/\\/ Gray code output\n  output     [WIDTH-1:0] bin_out    \\/\\/ Binary equivalent (for debug)\n);\n  reg [WIDTH-1:0] bin_next, bin_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      bin_reg <= 0;\n    else if (en)\n      bin_reg <= bin_next;\n  end\n\n  always @(*) begin\n    bin_next = bin_reg + 1;\n  end\n\n  assign bin_out = bin_reg;\n  assign gray_out = (bin_reg >> 1) ^ bin_reg;\nendmodule"
  },
  {
    "module_name": "async_fifo",
    "description": "An asynchronous (dual-clock) FIFO using Gray code pointers for safe CDC.",
    "verilog_code": "module async_fifo #(\n  parameter DATA_WIDTH = 8,\n  parameter ADDR_WIDTH = 4,\n  localparam DEPTH = 1 << ADDR_WIDTH\n) (\n  \\/\\/ Write Clock Domain\n  input wr_clk, wr_rst_n,\n  input wr_en, input [DATA_WIDTH-1:0] wr_data, output wr_full,\n  \\/\\/ Read Clock Domain\n  input rd_clk, rd_rst_n,\n  input rd_en, output [DATA_WIDTH-1:0] rd_data, output rd_empty\n);\n  reg [DATA_WIDTH-1:0] mem[0:DEPTH-1];\n  reg [ADDR_WIDTH:0] wr_ptr_bin, rd_ptr_bin;\n  wire [ADDR_WIDTH:0] wr_ptr_gray, rd_ptr_gray;\n  reg [ADDR_WIDTH:0] wr_ptr_gray_sync, rd_ptr_gray_sync;\n\n  \\/\\/ Write domain logic\n  always @(posedge wr_clk or negedge wr_rst_n) begin\n    if (!wr_rst_n) wr_ptr_bin <= 0;\n    else if (wr_en && !wr_full) wr_ptr_bin <= wr_ptr_bin + 1;\n  end\n  always @(posedge wr_clk) mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;\n  assign wr_ptr_gray = (wr_ptr_bin >> 1) ^ wr_ptr_bin;\n  assign wr_full = (wr_ptr_gray == {~rd_ptr_gray_sync[ADDR_WIDTH:ADDR_WIDTH-1], rd_ptr_gray_sync[ADDR_WIDTH-2:0]});\n\n  \\/\\/ Read domain logic\n  always @(posedge rd_clk or negedge rd_rst_n) begin\n    if (!rd_rst_n) rd_ptr_bin <= 0;\n    else if (rd_en && !rd_empty) rd_ptr_bin <= rd_ptr_bin + 1;\n  end\n  assign rd_data = mem[rd_ptr_bin[ADDR_WIDTH-1:0]];\n  assign rd_ptr_gray = (rd_ptr_bin >> 1) ^ rd_ptr_bin;\n  assign rd_empty = (wr_ptr_gray_sync == rd_ptr_gray);\n\n  \\/\\/ CDC Synchronizers\n  cdc_2flop_synchronizer #(.WIDTH(ADDR_WIDTH+1)) sync_rd_ptr (.clk(wr_clk), .rst_n(wr_rst_n), .data_in(rd_ptr_gray), .data_out(rd_ptr_gray_sync));\n  cdc_2flop_synchronizer #(.WIDTH(ADDR_WIDTH+1)) sync_wr_ptr (.clk(rd_clk), .rst_n(rd_rst_n), .data_in(wr_ptr_gray), .data_out(wr_ptr_gray_sync));\nendmodule"
  },
  {
    "module_name": "apb_slave",
    "description": "A generic APB slave for memory-mapped register access.",
    "verilog_code": "module apb_slave #(\n  parameter ADDR_WIDTH = 12,\n  parameter DATA_WIDTH = 32\n) (\n  input                       pclk,\n  input                       preset_n,\n  input [ADDR_WIDTH-1:0]      paddr,\n  input [2:0]                 pprot,\n  input                       psel,\n  input                       penable,\n  input                       pwrite,\n  input [DATA_WIDTH-1:0]      pwdata,\n  input [(DATA_WIDTH/8)-1:0]  pstrb,\n  output reg                  pready,\n  output reg [DATA_WIDTH-1:0] prdata,\n  output reg                  pslverr\n);\n  reg [DATA_WIDTH-1:0] reg0, reg1; \\/\\/ Example registers\n\n  wire access = psel & penable;\n  always @(posedge pclk or negedge preset_n) begin\n    if (!preset_n) begin\n      pready <= 1'b0;\n      pslverr <= 1'b0;\n      prdata <= 0;\n      reg0 <= 0;\n      reg1 <= 0;\n    end else begin\n      pready <= access; \\/\\/ Single cycle ready\n      pslverr <= 1'b0;   \\/\\/ No error logic for now\n\n      if (access && pwrite) begin\n        case (paddr[3:2]) \\/\\/ Simple decoding for 2 regs\n          2'b00: reg0 <= pwdata;\n          2'b01: reg1 <= pwdata;\n        endcase\n      end\n\n      if(access && !pwrite) begin\n         case (paddr[3:2])\n             2'b00: prdata <= reg0;\n             2'b01: prdata <= reg1;\n             default: prdata <= 0;\n         endcase\n      end else begin\n          prdata <= 0;\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "axi4_lite_slave",
    "description": "A basic AXI4-Lite slave interface for memory-mapped registers.",
    "verilog_code": "module axi4_lite_slave #(\n  parameter C_S_AXI_DATA_WIDTH = 32,\n  parameter C_S_AXI_ADDR_WIDTH = 4\n) (\n  input aclk, aresetn,\n  \\/\\/ AXI signals\n  input [C_S_AXI_ADDR_WIDTH-1:0] awaddr, input awvalid, output awready,\n  input [C_S_AXI_DATA_WIDTH-1:0] wdata, input [C_S_AXI_DATA_WIDTH/8-1:0] wstrb, input wvalid, output wready,\n  output [1:0] bresp, output bvalid, input bready,\n  input [C_S_AXI_ADDR_WIDTH-1:0] araddr, input arvalid, output arready,\n  output [C_S_AXI_DATA_WIDTH-1:0] rdata, output [1:0] rresp, output rvalid, input rready\n);\n  reg [C_S_AXI_ADDR_WIDTH-1:0] axi_awaddr, axi_araddr;\n  reg axi_awready, axi_wready, axi_arready, axi_rvalid, axi_bvalid;\n\n  always @(posedge aclk) begin\n    if (!aresetn) begin\n      axi_awready <= 0; axi_wready <= 0; axi_bvalid <= 0; axi_arready <= 0; axi_rvalid <= 0;\n    end else begin\n      \\/\\/ Write channel logic\n      axi_awready <= ~axi_awready & awvalid; \\/\\/ Simplified handshake\n      axi_wready <= ~axi_wready & wvalid & axi_awready; \n      if (axi_awready & awvalid) axi_awaddr <= awaddr;\n      if (axi_wready & wvalid) begin \\/\\/ Write to internal regs here \n      end\n      if(axi_wready & wvalid) axi_bvalid <= 1'b1;\n      else if (bready) axi_bvalid <= 1'b0;\n\n      \\/\\/ Read channel logic\n      axi_arready <= ~axi_arready & arvalid;\n      if (axi_arready & arvalid) begin \n        axi_araddr <= araddr; \n        axi_rvalid <= 1'b1;\n      end\n      else if(rready) axi_rvalid <= 1'b0;\n    end\n  end\n  assign awready = axi_awready; assign wready = axi_wready;\n  assign bresp = 2'b00; assign bvalid = axi_bvalid;\n  assign arready = axi_arready; \n  assign rdata = 32'hDEADBEEF; \\/\\/ Example read data\n  assign rresp = 2'b00; assign rvalid = axi_rvalid;\nendmodule"
  },
  {
    "module_name": "axi_stream_packetizer",
    "description": "Packetizes a continuous stream of data into AXI-Stream packets with TLAST.",
    "verilog_code": "module axi_stream_packetizer #(\n  parameter DATA_WIDTH = 32,\n  parameter PACKET_LEN = 16 \\/\\/ Number of data words per packet\n) (\n  input clk, rst_n,\n  \\/\\/ Input stream\n  input [DATA_WIDTH-1:0] s_data,\n  input s_valid, \n  output s_ready,\n  \\/\\/ AXI Stream Output\n  output [DATA_WIDTH-1:0] m_axis_tdata,\n  output reg m_axis_tlast,\n  output m_axis_tvalid,\n  input m_axis_tready\n);\n  reg [$clog2(PACKET_LEN)-1:0] counter;\n  wire transfer = m_axis_tvalid & m_axis_tready;\n\n  assign m_axis_tdata = s_data;\n  assign m_axis_tvalid = s_valid;\n  assign s_ready = m_axis_tready;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      counter <= 0;\n      m_axis_tlast <= 0;\n    end else if (transfer) begin\n      if (counter == PACKET_LEN - 1) begin\n        counter <= 0;\n        m_axis_tlast <= 1'b1;\n      end else begin\n        counter <= counter + 1;\n        m_axis_tlast <= 1'b0;\n      end\n    end else begin\n      m_axis_tlast <= 1'b0;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "pipeline_stage_valid_ready",
    "description": "A generic, backpressure-aware pipeline stage using a valid/ready handshake.",
    "verilog_code": "module pipeline_stage_valid_ready #(\n  parameter DATA_WIDTH = 32\n) (\n  input clk, rst_n,\n  \\/\\/ Slave (input) side\n  input [DATA_WIDTH-1:0] s_data,\n  input s_valid,\n  output s_ready,\n  \\/\\/ Master (output) side\n  output [DATA_WIDTH-1:0] m_data,\n  output m_valid,\n  input m_ready\n);\n  reg [DATA_WIDTH-1:0] data_reg;\n  reg valid_reg;\n\n  wire stall = valid_reg & ~m_ready;\n  assign s_ready = ~stall;\n  \n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      valid_reg <= 1'b0;\n    end else begin\n      if (s_ready) begin\n        valid_reg <= s_valid;\n      end\n    end\n  end\n\n  always @(posedge clk) begin\n    if (s_ready) begin\n      data_reg <= s_data;\n    end\n  end\n\n  assign m_data = data_reg;\n  assign m_valid = valid_reg;\nendmodule"
  },
  {
    "module_name": "elastic_buffer",
    "description": "A two-stage elastic buffer (or skid buffer) to help close timing in pipelined systems.",
    "verilog_code": "module elastic_buffer #(\n  parameter DATA_WIDTH = 32\n) (\n  input clk, rst_n,\n  \\/\\/ Slave (input) side\n  input [DATA_WIDTH-1:0] s_data,\n  input s_valid,\n  output s_ready,\n  \\/\\/ Master (output) side\n  output [DATA_WIDTH-1:0] m_data,\n  output m_valid,\n  input m_ready\n);\n  reg [DATA_WIDTH-1:0] data_stage1, data_stage2;\n  reg valid_stage1, valid_stage2;\n\n  wire stage1_ready = ~valid_stage2 | m_ready;\n  wire stage2_fire = valid_stage2 & m_ready;\n  wire stage1_fire = valid_stage1 & stage1_ready;\n\n  assign s_ready = stage1_ready;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      valid_stage1 <= 1'b0;\n      valid_stage2 <= 1'b0;\n    end else begin\n      if(stage1_ready) valid_stage1 <= s_valid;\n      if(stage2_fire) valid_stage2 <= 1'b0;\n      if(stage1_fire) valid_stage2 <= 1'b1;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (stage1_ready) data_stage1 <= s_data;\n    if (stage1_fire) data_stage2 <= data_stage1;\n  end\n\n  assign m_data = valid_stage2 ? data_stage2 : data_stage1;\n  assign m_valid = valid_stage1 | valid_stage2;\nendmodule"
  },
  {
    "module_name": "credit_flow_control_unit",
    "description": "A credit-based flow control sender unit.",
    "verilog_code": "module credit_flow_control_unit #(\n  parameter CREDIT_WIDTH = 4\n) (\n  input clk, rst_n,\n  \\/\\/ Data send interface\n  input send_req, \\/\\/ Request to send data\n  output send_grant, \\/\\/ Grant to send data\n  \\/\\/ Credit return interface\n  input credit_return \\/\\/ A credit has been returned from receiver\n);\n  reg [CREDIT_WIDTH-1:0] credit_count;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      credit_count <= 2**CREDIT_WIDTH - 1; \\/\\/ Initial credits\n    end else begin\n      if (credit_return && !send_grant)\n        credit_count <= credit_count + 1;\n      else if (!credit_return && send_grant)\n        credit_count <= credit_count - 1;\n    end\n  end\n\n  assign send_grant = send_req & (credit_count > 0);\nendmodule"
  },
  {
    "module_name": "fir_filter",
    "description": "A parameterized, fully parallel Finite Impulse Response (FIR) filter.",
    "verilog_code": "module fir_filter #(\n  parameter DATA_WIDTH = 16,\n  parameter COEFF_WIDTH = 16,\n  parameter NUM_TAPS = 8\n) (\n  input clk, rst_n,\n  input signed [DATA_WIDTH-1:0] data_in, \\/\\/ Input sample stream\n  input [NUM_TAPS*COEFF_WIDTH-1:0] coeffs, \\/\\/ Filter coefficients\n  output signed [DATA_WIDTH+COEFF_WIDTH+$clog2(NUM_TAPS)-1:0] data_out \\/\\/ Filtered output\n);\n  reg signed [DATA_WIDTH-1:0] delay_line [0:NUM_TAPS-1];\n  wire signed [DATA_WIDTH+COEFF_WIDTH-1:0] products [0:NUM_TAPS-1];\n  reg signed [DATA_WIDTH+COEFF_WIDTH+$clog2(NUM_TAPS)-1:0] result;\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n      for (i=0; i < NUM_TAPS; i=i+1) delay_line[i] <= 0;\n    end else begin\n      delay_line[0] <= data_in;\n      for (i=1; i < NUM_TAPS; i=i+1) begin\n        delay_line[i] <= delay_line[i-1];\n      end\n    end\n  end\n\n  genvar j;\n  generate\n    for (j=0; j < NUM_TAPS; j=j+1) begin : mult_gen\n      assign products[j] = delay_line[j] * coeffs[(j+1)*COEFF_WIDTH-1:j*COEFF_WIDTH];\n    end\n  endgenerate\n\n  always @(*) begin\n    result = 0;\n    for (i=0; i < NUM_TAPS; i=i+1) begin\n      result = result + products[i];\n    end\n  end\n  assign data_out = result;\nendmodule"
  },
  {
    "module_name": "fixed_point_mac",
    "description": "A registered Multiply-Accumulate (MAC) unit for fixed-point numbers.",
    "verilog_code": "module fixed_point_mac #(\n  parameter DATA_WIDTH = 16,\n  parameter ACCUM_WIDTH = 48\n) (\n  input clk, rst_n, en,\n  input signed [DATA_WIDTH-1:0] a,\n  input signed [DATA_WIDTH-1:0] b,\n  output reg signed [ACCUM_WIDTH-1:0] p\n);\n  wire signed [2*DATA_WIDTH-1:0] product = a * b;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      p <= 0;\n    end else if (en) begin\n      p <= p + product;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "cordic_vectoring_mode",
    "description": "A CORDIC engine in vectoring mode to compute magnitude and angle of an (x, y) vector.",
    "verilog_code": "module cordic_vectoring_mode #(\n  parameter WIDTH = 16,\n  parameter ITERATIONS = 16\n) (\n  input clk, rst_n, start,\n  input signed [WIDTH-1:0] x_in, y_in,\n  output reg signed [WIDTH-1:0] magnitude,\n  output reg signed [WIDTH-1:0] angle,\n  output reg done\n);\n  \\/\\/ This is a structural placeholder. A full CORDIC requires a stage for each iteration\n  \\/\\/ and a lookup table for arctan values.\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) done <= 1'b0;\n    else if (start) done <= 1'b0;\n    else if (1) done <= 1'b1; // Simplified completion\n  end\nendmodule"
  },
  {
    "module_name": "pid_controller",
    "description": "A digital Proportional-Integral-Derivative (PID) controller.",
    "verilog_code": "module pid_controller #(\n  parameter DATA_WIDTH = 16\n) (\n  input clk, rst_n,\n  input signed [DATA_WIDTH-1:0] set_point,\n  input signed [DATA_WIDTH-1:0] process_var,\n  input signed [DATA_WIDTH-1:0] Kp, Ki, Kd, \\/\\/ PID gains\n  output signed [DATA_WIDTH-1:0] control_out\n);\n  reg signed [DATA_WIDTH-1:0] error, prev_error;\n  reg signed [DATA_WIDTH*2-1:0] integral;\n  wire signed [DATA_WIDTH-1:0] derivative;\n  wire signed [DATA_WIDTH-1:0] p_term, i_term, d_term;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      prev_error <= 0;\n      integral <= 0;\n    end else begin\n      error <= set_point - process_var;\n      prev_error <= error;\n      integral <= integral + error;\n    end\n  end\n\n  assign derivative = error - prev_error;\n  assign p_term = Kp * error;\n  assign i_term = Ki * integral; \\/\\/ Note: Scaling is required\n  assign d_term = Kd * derivative;\n  assign control_out = p_term + i_term + d_term;\nendmodule"
  },
  {
    "module_name": "interrupt_controller",
    "description": "A basic interrupt controller with fixed priority.",
    "verilog_code": "module interrupt_controller #(\n  parameter NUM_IRQS = 8\n) (\n  input clk, rst_n,\n  input [NUM_IRQS-1:0] irq_sources, \\/\\/ Raw interrupt request lines\n  output reg irq_out,               \\/\\/ Master interrupt line to CPU\n  output reg [$clog2(NUM_IRQS)-1:0] irq_vector \\/\\/ Encoded vector of highest priority IRQ\n);\n  wire [NUM_IRQS-1:0] pending_irqs;\n  reg [NUM_IRQS-1:0] irq_latches;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) irq_latches <= 0;\n    else irq_latches <= irq_latches | irq_sources;\n  end\n\n  assign pending_irqs = irq_latches;\n\n  always @(*) begin\n    if (|pending_irqs) begin\n      irq_out = 1'b1;\n      // Priority encoder finds the highest priority pending IRQ\n      // (Assumes lower index is higher priority)\n      if(pending_irqs[0]) irq_vector = 0;\n      else if(pending_irqs[1]) irq_vector = 1;\n      // ... and so on\n    end else begin\n      irq_out = 1'b0;\n      irq_vector = 0;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "watchdog_timer",
    "description": "A watchdog timer that triggers a reset if not 'petted' periodically.",
    "verilog_code": "module watchdog_timer #(\n  parameter TIMEOUT_CYCLES = 1_000_000,\n  localparam COUNTER_WIDTH = $clog2(TIMEOUT_CYCLES)\n) (\n  input clk,\n  input rst_n, \\/\\/ System reset\n  input pet_wdt, \\/\\/ Pet the watchdog to reset its counter\n  output wdt_reset \\/\\/ Fires when the timer expires\n);\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n || pet_wdt) begin\n      counter <= 0;\n    end else if (counter < TIMEOUT_CYCLES - 1) begin\n      counter <= counter + 1;\n    end\n  end\n\n  assign wdt_reset = (counter == TIMEOUT_CYCLES - 1);\nendmodule"
  },
  {
    "module_name": "crc32_parallel",
    "description": "A parallel CRC-32 generator (Ethernet polynomial 0x04C11DB7).",
    "verilog_code": "module crc32_parallel #(\n  parameter DATA_WIDTH = 8\n) (\n  input clk, rst_n,\n  input [31:0] crc_in, \\/\\/ Current CRC value\n  input [DATA_WIDTH-1:0] data_in, \\/\\/ Input data byte\n  output [31:0] crc_out \\/\\/ Next CRC value\n);\n  // A full parallel implementation is a large combinational block.\n  // This is a placeholder showing the concept.\n  wire [31:0] next_crc;\n  // Logic here would compute next_crc = crc_in XOR f(data_in)\n  assign crc_out = next_crc;\nendmodule"
  },
  {
    "module_name": "serdes_8b10b_encoder",
    "description": "An 8b/10b encoder block (combinational logic).",
    "verilog_code": "module serdes_8b10b_encoder(\n  input [7:0] data_in,\n  input       is_control, \\/\\/ K-character flag\n  output [9:0] code_out,\n  output       disparity_error\n);\n  \\/\\/ This would contain a large case statement or LUT for the 8b/10b encoding rules.\n  \\/\\/ The logic depends on running disparity, which is not shown here for simplicity.\n  assign code_out = 10'h0; \\/\\/ Placeholder\n  assign disparity_error = 1'b0;\nendmodule"
  },
  {
    "module_name": "serializer_10_to_1",
    "description": "A 10-to-1 serializer for high-speed interfaces.",
    "verilog_code": "module serializer_10_to_1 #(\n    parameter WIDTH = 10\n) (\n    input clk,       \\/\\/ Parallel clock\n    input rst_n,\n    input [WIDTH-1:0] p_data, \\/\\/ Parallel data in\n    input p_valid,   \\/\\/ Valid signal for parallel data\n    output reg s_data, \\/\\/ Serial data out\n    output reg s_valid \\/\\/ Serial data valid\n);\n    reg [WIDTH-1:0] shift_reg;\n    reg [3:0] bit_count;\n    reg busy;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_reg <= 0;\n            bit_count <= 0;\n            busy <= 0;\n            s_data <= 0;\n            s_valid <= 0;\n        end else begin\n            if (p_valid && !busy) begin\n                shift_reg <= p_data;\n                busy <= 1'b1;\n                s_valid <= 1'b1;\n                bit_count <= 0;\n            end else if (busy) begin\n                shift_reg <= shift_reg << 1;\n                bit_count <= bit_count + 1;\n                if (bit_count == WIDTH-1) begin\n                    busy <= 1'b0;\n                    s_valid <= 1'b0;\n                end\n            end\n            s_data <= shift_reg[WIDTH-1];\n        end\n    end\nendmodule"
  },
  {
    "module_name": "deserializer_1_to_10",
    "description": "A 1-to-10 deserializer for high-speed interfaces.",
    "verilog_code": "module deserializer_1_to_10 #(\n    parameter WIDTH = 10\n) (\n    input clk, \\/\\/ Serial clock (faster)\n    input rst_n,\n    input s_data, \\/\\/ Serial data in\n    input s_valid, \\/\\/ Valid for serial data\n    output reg [WIDTH-1:0] p_data, \\/\\/ Parallel data out\n    output reg p_valid \\/\\/ Valid for parallel data\n);\n    reg [WIDTH-1:0] shift_reg;\n    reg [3:0] bit_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            bit_count <= 0;\n            p_valid <= 0;\n        end else begin\n            p_valid <= 0; \\/\\/ Pulse behavior\n            if (s_valid) begin\n                shift_reg <= {shift_reg[WIDTH-2:0], s_data};\n                if (bit_count == WIDTH-1) begin\n                    bit_count <= 0;\n                    p_data <= {shift_reg[WIDTH-2:0], s_data};\n                    p_valid <= 1'b1;\n                end else begin\n                    bit_count <= bit_count + 1;\n                end\n            end\n        end\n    end\nendmodule"
  },
  {
    "module_name": "csr_map_generic",
    "description": "A generic Control/Status Register (CSR) map with a simple bus interface.",
    "verilog_code": "module csr_map_generic #(\n  parameter NUM_REGS = 4,\n  parameter DATA_WIDTH = 32,\n  localparam ADDR_WIDTH = $clog2(NUM_REGS)\n) (\n  input clk, rst_n,\n  \\/\\/ Simple bus interface\n  input [ADDR_WIDTH-1:0] addr,\n  input [DATA_WIDTH-1:0] wdata,\n  input wr_en, rd_en,\n  output [DATA_WIDTH-1:0] rdata\n);\n  reg [DATA_WIDTH-1:0] registers [0:NUM_REGS-1];\n  reg [DATA_WIDTH-1:0] rdata_reg;\n  integer i;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      for (i=0; i<NUM_REGS; i=i+1) registers[i] <= 0;\n    end else if (wr_en) begin\n      registers[addr] <= wdata;\n    end\n  end\n\n  always @(posedge clk) begin\n      if(rd_en) rdata_reg <= registers[addr];\n  end\n  assign rdata = rdata_reg;\nendmodule"
  },
  {
    "module_name": "timebase_counter_64bit",
    "description": "A 64-bit free-running counter, useful as a system timebase.",
    "verilog_code": "module timebase_counter_64bit (\n  input             clk,\n  input             rst_n,\n  input             en,      \\/\\/ Enable counting\n  output [63:0]     count\n);\n  reg [63:0] count_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      count_reg <= 64'd0;\n    end else if (en) begin\n      count_reg <= count_reg + 1;\n    end\n  end\n  assign count = count_reg;\nendmodule"
  },
  {
    "module_name": "gpio_interruptible",
    "description": "A GPIO pin with configurable edge-triggered interrupt capability.",
    "verilog_code": "module gpio_interruptible (\n  input clk, rst_n,\n  input oe, input data_out, output data_in,\n  inout pin,\n  \\/\\/ Interrupt config\n  input irq_en,       \\/\\/ Enable interrupt for this pin\n  input irq_posedge,  \\/\\/ Trigger on posedge\n  input irq_negedge,  \\/\\/ Trigger on negedge\n  output reg irq_out  \\/\\/ Interrupt status flag (level)\n);\n  reg pin_d1;\n  wire posedge_event = data_in & ~pin_d1;\n  wire negedge_event = ~data_in & pin_d1;\n  wire event_fire = (irq_posedge & posedge_event) | (irq_negedge & negedge_event);\n\n  assign pin = oe ? data_out : 1'bz;\n  assign data_in = pin;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      pin_d1 <= 0;\n      irq_out <= 0;\n    end else begin\n      pin_d1 <= data_in;\n      if (irq_en & event_fire) irq_out <= 1'b1;\n      else irq_out <= irq_out; \\/\\/ User must clear via CSR\n    end\n  end\nendmodule"
  },
  {
    "module_name": "crossbar_switch_2x2_rr",
    "description": "A 2x2 crossbar switch using round-robin arbiters for slave contention.",
    "verilog_code": "module crossbar_switch_2x2_rr #(\n  parameter DATA_WIDTH = 32\n) (\n  input clk, rst_n,\n  \\/\\/ Master 0 Interface\n  input m0_req, output m0_gnt, input [DATA_WIDTH-1:0] m0_data, input m0_dest, \\/\\/ 0=S0, 1=S1\n  \\/\\/ Master 1 Interface\n  input m1_req, output m1_gnt, input [DATA_WIDTH-1:0] m1_data, input m1_dest,\n  \\/\\/ Slave 0 Interface\n  output s0_req, input s0_gnt, output [DATA_WIDTH-1:0] s0_data, output s0_src,\n  \\/\\/ Slave 1 Interface\n  output s1_req, input s1_gnt, output [DATA_WIDTH-1:0] s1_data, output s1_src\n);\n  wire s0_req_from_m0 = m0_req & ~m0_dest;\n  wire s0_req_from_m1 = m1_req & ~m1_dest;\n  wire s1_req_from_m0 = m0_req & m0_dest;\n  wire s1_req_from_m1 = m1_req & m1_dest;\n\n  wire [1:0] s0_gnts, s1_gnts;\n\n  arbiter_round_robin #(.NUM_REQUESTERS(2)) arb_s0 (clk, rst_n, {s0_req_from_m1, s0_req_from_m0}, s0_gnts);\n  arbiter_round_robin #(.NUM_REQUESTERS(2)) arb_s1 (clk, rst_n, {s1_req_from_m1, s1_req_from_m0}, s1_gnts);\n  \n  assign m0_gnt = (s0_gnts[0] & ~m0_dest) | (s1_gnts[0] & m0_dest);\n  assign m1_gnt = (s0_gnts[1] & ~m1_dest) | (s1_gnts[1] & m1_dest);\n\n  assign s0_req = s0_gnts[0] | s0_gnts[1];\n  assign s1_req = s1_gnts[0] | s1_gnts[1];\n\n  assign s0_data = s0_gnts[1] ? m1_data : m0_data;\n  assign s1_data = s1_gnts[1] ? m1_data : m0_data;\n  assign s0_src = s0_gnts[1];\n  assign s1_src = s1_gnts[1];\nendmodule"
  },
  {
    "module_name": "dot_product_engine",
    "description": "Calculates the dot product of two vectors.",
    "verilog_code": "module dot_product_engine #(\n  parameter VEC_LEN = 4,\n  parameter DATA_WIDTH = 8\n) (\n  input clk, rst_n, start,\n  input signed [VEC_LEN*DATA_WIDTH-1:0] vec_a,\n  input signed [VEC_LEN*DATA_WIDTH-1:0] vec_b,\n  output reg signed [2*DATA_WIDTH+$clog2(VEC_LEN)-1:0] result,\n  output reg done\n);\n  reg signed [2*DATA_WIDTH-1:0] products [0:VEC_LEN-1];\n  integer i;\n\n  always @(posedge clk) begin\n    if (start) begin\n      for (i=0; i<VEC_LEN; i=i+1) begin\n        products[i] <= vec_a[(i+1)*DATA_WIDTH-1:i*DATA_WIDTH] * vec_b[(i+1)*DATA_WIDTH-1:i*DATA_WIDTH];\n      end\n    end\n  end\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      result <= 0;\n      done <= 0;\n    end else if(start) begin\n      done <= 0;\n    end else begin\n      result <= products[0] + products[1] + products[2] + products[3]; \\/\\/ Adder tree needed for large VEC_LEN\n      done <= 1'b1;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "relu_activation",
    "description": "A Rectified Linear Unit (ReLU) activation function for neural networks.",
    "verilog_code": "module relu_activation #(\n  parameter DATA_WIDTH = 16\n) (\n  input signed [DATA_WIDTH-1:0] data_in, \\/\\/ Input value\n  output [DATA_WIDTH-1:0] data_out \\/\\/ Output value (max(0, data_in))\n);\n  wire is_neg = data_in[DATA_WIDTH-1];\n  assign data_out = is_neg ? 0 : data_in;\nendmodule"
  },
  {
    "module_name": "multiplier_pipelined_3_stage",
    "description": "A parameterized N-bit pipelined multiplier with 3 stages.",
    "verilog_code": "module multiplier_pipelined_3_stage #(\n  parameter WIDTH = 16\n) (\n  input                        clk, rst_n,\n  input      [WIDTH-1:0]       a,\n  input      [WIDTH-1:0]       b,\n  output reg [2*WIDTH-1:0]     prod\n);\n  reg [WIDTH-1:0] a_p1, b_p1;\n  reg [WIDTH-1:0] a_p2, b_p2;\n  wire [2*WIDTH-1:0] product_comb = a_p2 * b_p2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        a_p1 <= 0; b_p1 <= 0;\n        a_p2 <= 0; b_p2 <= 0;\n        prod <= 0;\n    end else begin\n        \\/\\/ Stage 1: Register inputs\n        a_p1 <= a;\n        b_p1 <= b;\n        \\/\\/ Stage 2: Register inputs again\n        a_p2 <= a_p1;\n        b_p2 <= b_p1;\n        \\/\\/ Stage 3: Register output of combinational multiply\n        prod <= product_comb;\n    end\n  end\nendmodule"
  },
  {
    "module_name": "uart_tx",
    "description": "A standard UART transmitter module with configurable baud rate.",
    "verilog_code": "module uart_tx #(\n  parameter CLK_FREQ = 50_000_000,\n  parameter BAUD_RATE = 115200\n) (\n  input clk, rst_n,\n  input tx_start, input [7:0] tx_data,\n  output tx_serial, output reg tx_busy\n);\n  localparam DIVISOR = CLK_FREQ / BAUD_RATE;\n  localparam S_IDLE = 2'd0, S_START = 2'd1, S_DATA = 2'd2, S_STOP = 2'd3;\n  reg [1:0] state;\n  reg [$clog2(DIVISOR)-1:0] clk_count;\n  reg [2:0] bit_count;\n  reg [9:0] tx_shift_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      state <= S_IDLE;\n      tx_busy <= 1'b0;\n      clk_count <= 0;\n      bit_count <= 0;\n      tx_shift_reg <= 10'h3FF; \\/\\/ Idle state (all 1s)\n    end else begin\n      case(state)\n        S_IDLE:\n          if (tx_start) begin\n            tx_shift_reg <= {1'b1, tx_data, 1'b0}; \\/\\/ Stop, Data, Start\n            state <= S_START;\n            tx_busy <= 1'b1;\n            clk_count <= 0;\n            bit_count <= 0;\n          end\n        S_START, S_DATA, S_STOP:\n          if (clk_count == DIVISOR - 1) begin\n            clk_count <= 0;\n            tx_shift_reg <= {1'b1, tx_shift_reg[9:1]}; \\/\\/ Shift out LSB\n            bit_count <= bit_count + 1;\n            if (bit_count == 10) begin\n              state <= S_IDLE;\n              tx_busy <= 1'b0;\n            end\n          end else begin\n            clk_count <= clk_count + 1;\n          end\n      endcase\n    end\n  end\n  assign tx_serial = tx_shift_reg[0];\nendmodule"
  },
  {
    "module_name": "spi_master",
    "description": "A basic SPI master supporting Mode 0 (CPOL=0, CPHA=0).",
    "verilog_code": "module spi_master #(\n  parameter CLK_DIV = 4\n) (\n  input clk, rst_n,\n  input start, input [7:0] data_tx,\n  output reg [7:0] data_rx, output reg busy, \n  output reg spi_sck, output spi_mosi, input spi_miso, output spi_cs_n\n);\n  reg [$clog2(CLK_DIV)-1:0] clk_count;\n  reg [3:0] bit_count;\n  reg [7:0] tx_reg, rx_reg;\n  reg cs_reg;\n  assign spi_mosi = tx_reg[7]; assign spi_cs_n = cs_reg;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      busy <= 0; spi_sck <= 0; clk_count <= 0; bit_count <= 0; cs_reg <= 1;\n    end else begin\n      if (start && !busy) begin\n        busy <= 1'b1; cs_reg <= 0; tx_reg <= data_tx; clk_count <= 0; bit_count <= 0; spi_sck <= 0;\n      end else if (busy) begin\n        if (clk_count == CLK_DIV-1) begin \\/\\/ Falling edge of spi_sck\n          spi_sck <= 0; clk_count <= 0;\n          if (bit_count == 8) begin\n            busy <= 0; cs_reg <= 1; data_rx <= rx_reg;\n          end else tx_reg <= tx_reg << 1;\n        end else if (clk_count == CLK_DIV/2-1) begin \\/\\/ Rising edge of spi_sck\n          spi_sck <= 1'b1; clk_count <= clk_count + 1;\n          rx_reg <= {rx_reg[6:0], spi_miso}; bit_count <= bit_count + 1;\n        end else clk_count <= clk_count + 1;\n      end\n    end\n  end\nendmodule"
  },
  {
    "module_name": "i2c_master_fsm",
    "description": "A state machine for a basic I2C master (data path and clock gen separate).",
    "verilog_code": "module i2c_master_fsm (\n  input clk, rst_n,\n  input start_req, input stop_req, input read_req, input write_req, input [6:0] slave_addr, input [7:0] wdata,\n  output reg [7:0] rdata, output reg busy, output reg error_no_ack,\n  output reg gen_start, output reg gen_stop, output reg drive_sda, output reg sample_ack\n);\n  localparam S_IDLE=0, S_START=1, S_ADDR=2, S_ACK1=3, S_WDATA=4, S_ACK2=5, S_STOP=6;\n  reg [2:0] state;\n\n  always @(posedge clk or negedge rst_n) begin\n      if (!rst_n) state <= S_IDLE;\n      else begin\n          // FSM logic to drive control signals based on state and inputs\n      end\n  end\nendmodule"
  },
  {
    "module_name": "pwm_generator",
    "description": "A Pulse-Width Modulation (PWM) generator with configurable period and duty cycle.",
    "verilog_code": "module pwm_generator #(\n  parameter COUNTER_WIDTH = 8\n) (\n  input                         clk, rst_n,\n  input [COUNTER_WIDTH-1:0]     period, \\/\\/ PWM period (max count + 1)\n  input [COUNTER_WIDTH-1:0]     duty,   \\/\\/ Duty cycle (compare value)\n  output reg                    pwm_out \\/\\/ PWM output signal\n);\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      counter <= 0;\n    end else begin\n      if (counter >= period - 1) begin\n        counter <= 0;\n      end else begin\n        counter <= counter + 1;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge rst_n) begin\n      if(!rst_n) pwm_out <= 0;\n      else pwm_out <= (counter < duty);\n  end\nendmodule"
  },
  {
    "module_name": "debouncer",
    "description": "A counter-based switch debouncer to filter out mechanical noise.",
    "verilog_code": "module debouncer #(\n  parameter CLK_FREQ = 50_000_000, \\/\\/ 50 MHz clock\n  parameter DEBOUNCE_TIME_MS = 10,  \\/\\/ 10 ms debounce time\n  localparam MAX_COUNT = CLK_FREQ * DEBOUNCE_TIME_MS / 1000,\n  localparam COUNT_WIDTH = $clog2(MAX_COUNT)\n) (\n  input                     clk,       \\/\\/ System clock\n  input                     rst_n,     \\/\\/ Async reset\n  input                     noisy_in,  \\/\\/ Raw input from a button/switch\n  output reg                clean_out  \\/\\/ Debounced output\n);\n  reg [COUNT_WIDTH-1:0] count;\n  reg noisy_in_sync1, noisy_in_sync2;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      noisy_in_sync1 <= 0; noisy_in_sync2 <= 0;\n    end else begin\n      noisy_in_sync1 <= noisy_in;\n      noisy_in_sync2 <= noisy_in_sync1;\n    end\n  end\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      count <= 0;\n      clean_out <= 0;\n    end else begin\n      if (noisy_in_sync2 != clean_out) begin\n        count <= count + 1;\n        if (count == MAX_COUNT - 1) begin\n          clean_out <= noisy_in_sync2;\n          count <= 0;\n        end\n      end else begin\n        count <= 0;\n      end\n    end\n  end\nendmodule"
  }
]
